CHR = data$CHR,
POS = c(data$POS1, data$POS2),
COUNT = rep(data$COUNT, 2),
FREQUENCY = rep(data$FREQUENCY, 2)
)
return(new_data)
}
# Initialize an empty list to store the split dataframes
split_data <- list()
# Iterate over each chromosome
for (CHR in unique(data$CHR)) {
# Subset data for the current chromosome
chr_data <- data[data$CHR == CHR, ]
# Split each window into two rows
split_data[[CHR]] <- split_window(chr_data)
}
# Combine all split dataframes into one
split_data_combined <- do.call(rbind, split_data)
# Export the combined split dataframe to TSV files for each chromosome
for (CHR in unique(data$CHR)) {
# Subset the split data for the current chromosome
chr_split_data <- split_data_combined[split_data_combined$CHR == CHR, ]
# # Define the filename
# filename <- paste("Chr", CHR, "_threshold_", threshold, "_ROH_freq.tsv", sep = "")
# Define the filename with the output directory path
filename <- file.path(output_dir_all_chr_roh_freq, paste("chr", CHR, "_threshold_", threshold,"_ROH_freq.tsv", sep = ""))
# Define the filename with the output directory path
filename <- file.path(output_dir_all_chr_roh_freq, paste("chr", CHR,"_ROH_freq", "_threshold_", threshold".tsv", sep = ""))
# Define a function to split each window into two rows
split_window <- function(data) {
# Create a new dataframe to store the split rows
new_data <- data.frame(
CHR = data$CHR,
POS = c(data$POS1, data$POS2),
COUNT = rep(data$COUNT, 2),
FREQUENCY = rep(data$FREQUENCY, 2)
)
return(new_data)
}
# Initialize an empty list to store the split dataframes
split_data <- list()
# Iterate over each chromosome
for (CHR in unique(data$CHR)) {
# Subset data for the current chromosome
chr_data <- data[data$CHR == CHR, ]
# Split each window into two rows
split_data[[CHR]] <- split_window(chr_data)
}
# Combine all split dataframes into one
split_data_combined <- do.call(rbind, split_data)
# Export the combined split dataframe to TSV files for each chromosome
for (CHR in unique(data$CHR)) {
# Subset the split data for the current chromosome
chr_split_data <- split_data_combined[split_data_combined$CHR == CHR, ]
# # Define the filename
# filename <- paste("Chr", CHR, "_threshold_", threshold, "_ROH_freq.tsv", sep = "")
# Define the filename with the output directory path
filename <- file.path(output_dir_all_chr_roh_freq, paste("chr", CHR, "_threshold_", threshold,"_ROH_freq.tsv", sep = ""))
# Define the filename with the output directory path
filename <- file.path(output_dir_all_chr_roh_freq, paste("chr", CHR,"_ROH_freq", "_threshold_", threshold,".tsv", sep = ""))
# Write data to TSV file without quotes and with tab separation
write.table(chr_split_data, file = filename, sep = "\t", row.names = FALSE, quote = FALSE)
}
knitr::opts_chunk$set(echo = TRUE)
####################################
# Defining the working directory
####################################
# Defining the relative path in the repository
repository_path <- "/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations"
# Set the path to your GitHub folder
YOUR_GITHUB_ROOT_DIRECTORY <- "C:/Users/jonat/GitHub"
# Set the root directory for notebook chunks
knitr::opts_knit$set(root.dir = file.path(YOUR_GITHUB_ROOT_DIRECTORY, repository_path))
####################################
# Defining the input file
####################################
input_file = "./results/Bedtools/empirical/german_shepherd/coverage/autosomes_100kb_window_size/results/sorted_pop_coverage.bed"
####################################
# Defining the output dirs
####################################
output_dir <- "./results/ROH-Hotspots (R)/empirical/german_shepherd/"
output_dir_gosling_plots <- file.path(output_directory_path, "Gosling plots/")
output_dir_all_chr_roh_freq <- file.path(output_dir_gosling_plots, "all_chr_roh_freq")
output_dir_roh_hotspots_freq <- file.path(output_dir_gosling_plots, "roh_hotspots_freq")
# # Verify the current working directory
# getwd()
# Iterate over unique chromosomes
for (chr in unique(linked_windows$CHR)) {
# Subset data for the current chromosome
chr_data <- linked_windows[linked_windows$CHR == chr, c("CHR", "POS1", "POS2")]
# Define the filename for the .bed file
filename <- paste0("CHR", chr, "_linked_windows.bed")
# Define the filename with the output directory path
filename <- file.path(output_dir_gosling_plots, paste("chr", CHR, "_ROH_Hotspot_windows.bed", sep = ""))
# Write data to .bed file
write.table(chr_data, file = filename, sep = "\t", quote = FALSE, col.names = FALSE, row.names = FALSE)
# Print message indicating successful export
cat("Exported", nrow(chr_data), "rows to", filename, "\n")
}
# Iterate over unique chromosomes
for (chr in unique(linked_windows$CHR)) {
# Subset data for the current chromosome
chr_data <- linked_windows[linked_windows$CHR == chr, c("CHR", "POS1", "POS2")]
# Define the filename with the output directory path
filename <- file.path(output_dir_gosling_plots, paste("chr",chr, "_ROH_Hotspot_windows.bed", sep = ""))
# Write data to .bed file
write.table(chr_data, file = filename, sep = "\t", quote = FALSE, col.names = FALSE, row.names = FALSE)
# Print message indicating successful export
cat("Exported", nrow(chr_data), "rows to", filename, "\n")
}
knitr::opts_chunk$set(echo = TRUE)
####################################
# Defining the working directory
####################################
# Defining the relative path in the repository
repository_path <- "/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations"
# Set the path to your GitHub folder
YOUR_GITHUB_ROOT_DIRECTORY <- "C:/Users/jonat/GitHub"
# Set the root directory for notebook chunks
knitr::opts_knit$set(root.dir = file.path(YOUR_GITHUB_ROOT_DIRECTORY, repository_path))
####################################
# Defining the input file
####################################
input_file = "./results/Bedtools/empirical/german_shepherd/coverage/autosomes_100kb_window_size/results/sorted_pop_coverage.bed"
####################################
# Defining the output dirs
####################################
output_dir <- "./results/ROH-Hotspots (R)/empirical/german_shepherd/"
output_dir_gosling_plots <- file.path(output_directory_path, "Gosling plots/")
knitr::opts_chunk$set(echo = TRUE)
####################################
# Defining the working directory
####################################
# Defining the relative path in the repository
repository_path <- "/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations"
# Set the path to your GitHub folder
YOUR_GITHUB_ROOT_DIRECTORY <- "C:/Users/jonat/GitHub"
# Set the root directory for notebook chunks
knitr::opts_knit$set(root.dir = file.path(YOUR_GITHUB_ROOT_DIRECTORY, repository_path))
####################################
# Defining the input file
####################################
input_file = "./results/Bedtools/empirical/german_shepherd/coverage/autosomes_100kb_window_size/results/sorted_pop_coverage.bed"
####################################
# Defining the output dirs
####################################
output_dir <- "./results/ROH-Hotspots (R)/empirical/german_shepherd/"
output_dir_gosling_plots <- file.path(output_dir, "Gosling plots/")
output_dir_all_chr_roh_freq <- file.path(output_dir_gosling_plots, "all_chr_roh_freq")
output_dir_roh_hotspots_freq <- file.path(output_dir_gosling_plots, "roh_hotspots_freq")
# # Verify the current working directory
# getwd()
# Load the MASS package for fitdistr function
library(MASS)
library(ggplot2)
# Read the data
#data <- read.table("sorted_population_coverage.bed", header = FALSE)
input_file = "./results/Bedtools/empirical/german_shepherd/coverage/autosomes_100kb_window_size/results/sorted_pop_coverage.bed"
data <- read.table(input_file, header = FALSE)
# data <- read.table("38_chr_sorted_population_coverage.bed", header = FALSE)
# Rename the columns
colnames(data) <- c("CHR", "POS1", "POS2", "COUNT", "FREQUENCY")
# Frequency Data is chosen
values <- data$FREQUENCY
# Sort the values in descending order to find the top 1%
sorted_values <- sort(values, decreasing = TRUE)
# Calculate the threshold for the top 1%
threshold_index <- ceiling(0.01 * length(sorted_values))
threshold <- sorted_values[threshold_index]
# Identify genomic windows with ROH frequency above the threshold
top_1_percent_ROH <- data[data$FREQUENCY > threshold, ]
# Print the top 1% of ROH regions
print(top_1_percent_ROH)
# Initialize an empty dataframe to store merged rows
merged_top_1_percent_ROH <- data.frame(CHR = character(), POS1 = integer(), POS2 = integer(), COUNT = integer(), FREQUENCY = numeric())
# Initialize a variable to store the previous row
prev_row <- NULL
# Iterate over each row in the top 1% ROH data
for (i in 1:nrow(top_1_percent_ROH)) {
# Get the current row
current_row <- top_1_percent_ROH[i, ]
# Check if it's the first row or if conditions for merging are met
if (!is.null(prev_row) && current_row$CHR == prev_row$CHR && current_row$COUNT == prev_row$COUNT && as.integer(current_row$POS1) == as.integer(prev_row$POS2) + 1) {
# Merge the current row with the previous one
prev_row$POS2 <- current_row$POS2
} else {
# If conditions for merging are not met, add the previous row to the merged dataframe
if (!is.null(prev_row)) {
merged_top_1_percent_ROH <- rbind(merged_top_1_percent_ROH, prev_row)
}
# Update the previous row to the current row
prev_row <- current_row
}
}
# Add the last row to the merged dataframe
if (!is.null(prev_row)) {
merged_top_1_percent_ROH <- rbind(merged_top_1_percent_ROH, prev_row)
}
# Calculate the length in kilobases (kb)
merged_top_1_percent_ROH$Length_kb <- (merged_top_1_percent_ROH$POS2 - merged_top_1_percent_ROH$POS1 + 1) / 1000
# Compute distance to previous and next window
merged_top_1_percent_ROH$Distance_to_prev_kb <- c(NA, diff(merged_top_1_percent_ROH$POS1)/1000)
merged_top_1_percent_ROH$Distance_to_next_kb <- c(diff(merged_top_1_percent_ROH$POS1)/1000, NA)
# Print the merged top 1% ROH data
print(merged_top_1_percent_ROH)
#max_win_gap <- 1*10^6
max_win_gap <- 2*10^6
# Initialize an empty dataframe to store linked windows
linked_windows <- data.frame(CHR = character(), POS1 = integer(), POS2 = integer(), Length_kb = numeric())
# Initialize variables to keep track of linked window
current_window <- NULL
# Iterate over each row in the merged dataframe
for (i in 1:nrow(merged_top_1_percent_ROH)) {
# Get the current row
current_row <- merged_top_1_percent_ROH[i, ]
# If it's the first row or if it's not within the specified distance from the previous window, start a new window
if (is.null(current_window) || current_row$POS1 - current_window$POS2 > max_win_gap || current_row$CHR != current_window$CHR) {
if (!is.null(current_window)) {
# Calculate Length_kb for the completed window and add it to the linked dataframe
current_window$Length_kb <- (current_window$POS2 - current_window$POS1 + 1) / 1000
linked_windows <- rbind(linked_windows, current_window[, c("CHR", "POS1", "POS2", "Length_kb")])
}
# Start a new window
current_window <- current_row
} else {
# Extend the current window
current_window$POS2 <- current_row$POS2
}
}
# Add the last window to the linked dataframe
if (!is.null(current_window)) {
current_window$Length_kb <- (current_window$POS2 - current_window$POS1 + 1) / 1000
linked_windows <- rbind(linked_windows, current_window[, c("CHR", "POS1", "POS2", "Length_kb")])
}
# Print the linked windows
print(linked_windows)
# Create scatter plots for each chromosome
for (CHR in unique(data$CHR)) {
# Subset data for the current chromosome
chr_data <- data[data$CHR == CHR, ]
chr_merged_data <- merged_top_1_percent_ROH[merged_top_1_percent_ROH$CHR == CHR, ]
# Create scatter plot
p <- ggplot() +
geom_point(data = chr_data, aes(x = POS1, y = FREQUENCY, color = "ROH-segments"), alpha = 0.5) +
geom_point(data = chr_merged_data, aes(x = POS1, y = FREQUENCY, color = "ROH hotspots"), alpha = 0.5) +
geom_hline(aes(yintercept = threshold, color = "ROH hotspot threshold"), linetype = "dashed") +
labs(title = paste("Scatter Plot for Chromosome", CHR),
x = "Position",
y = "FREQUENCY",
color = "Legend") +
scale_color_manual(values = c("ROH-segments" = "gray", "ROH hotspots" = "blue", "ROH hotspot threshold" = "red"),
labels = c("ROH-segments" = "ROH-segments", "ROH hotspots" = "ROH hotspots", "ROH hotspot threshold" = "ROH hotspot threshold")) +
theme_minimal()
# Print the plot
print(p)
}
# Define a function to split each window into two rows
split_window <- function(data) {
# Create a new dataframe to store the split rows
new_data <- data.frame(
CHR = data$CHR,
POS = c(data$POS1, data$POS2),
COUNT = rep(data$COUNT, 2),
FREQUENCY = rep(data$FREQUENCY, 2),
Length_kb = rep(data$Length_kb, 2),
Hotspot_interval = c(paste0("[", data$POS1, ",", data$POS2, "]"), paste0("[", data$POS1, ",", data$POS2, "]"))
)
return(new_data)
}
# Initialize an empty list to store the split dataframes
split_data <- list()
# Iterate over each chromosome
for (CHR in unique(merged_top_1_percent_ROH$CHR)) {
# Subset data for the current chromosome
chr_data <- merged_top_1_percent_ROH[merged_top_1_percent_ROH$CHR == CHR, ]
# Split each window into two rows
split_data[[CHR]] <- split_window(chr_data)
}
# Combine all split dataframes into one
split_data_combined <- do.call(rbind, split_data)
# Export the combined split dataframe to TSV files for each chromosome
for (CHR in unique(merged_top_1_percent_ROH$CHR)) {
# Subset the split data for the current chromosome
chr_split_data <- split_data_combined[split_data_combined$CHR == CHR, ]
# Define the filename with the output directory path
filename <- file.path(output_dir_roh_hotspots_freq, paste("chr", CHR, "_ROH_Hotspot_freq.tsv", sep = ""))
# Write data to TSV file without quotes and with tab separation
write.table(chr_split_data, file = filename, sep = "\t", row.names = FALSE, quote = FALSE)
}
knitr::opts_chunk$set(echo = TRUE)
####################################
# Defining the working directory
####################################
# Defining the relative path in the repository
repository_path <- "/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations"
# Set the path to your GitHub folder
YOUR_GITHUB_ROOT_DIRECTORY <- "C:/Users/jonat/GitHub"
# Set the root directory for notebook chunks
knitr::opts_knit$set(root.dir = file.path(YOUR_GITHUB_ROOT_DIRECTORY, repository_path))
####################################
# Defining the input file
####################################
input_file = "./results/Bedtools/empirical/german_shepherd/coverage/autosomes_100kb_window_size/results/sorted_pop_coverage.bed"
####################################
# Defining the output dirs
####################################
output_dir <- "./results/ROH-Hotspots (R)/empirical/german_shepherd/"
output_dir_gosling_plots <- file.path(output_dir, "Gosling plots/")
output_dir_all_chr_roh_freq <- file.path(output_dir_gosling_plots, "all_chr_roh_freq")
output_dir_roh_hotspots_freq <- file.path(output_dir_gosling_plots, "roh_hotspots_freq")
# # Verify the current working directory
# getwd()
# Load the MASS package for fitdistr function
library(MASS)
library(ggplot2)
# Read the data
#data <- read.table("sorted_population_coverage.bed", header = FALSE)
input_file = "./results/Bedtools/empirical/german_shepherd/coverage/autosomes_100kb_window_size/results/sorted_pop_coverage.bed"
data <- read.table(input_file, header = FALSE)
# data <- read.table("38_chr_sorted_population_coverage.bed", header = FALSE)
# Rename the columns
colnames(data) <- c("CHR", "POS1", "POS2", "COUNT", "FREQUENCY")
# Frequency Data is chosen
values <- data$FREQUENCY
# Sort the values in descending order to find the top 1%
sorted_values <- sort(values, decreasing = TRUE)
# Calculate the threshold for the top 1%
threshold_index <- ceiling(0.01 * length(sorted_values))
threshold <- sorted_values[threshold_index]
# Identify genomic windows with ROH frequency above the threshold
top_1_percent_ROH <- data[data$FREQUENCY > threshold, ]
# Print the top 1% of ROH regions
print(top_1_percent_ROH)
# Initialize an empty dataframe to store merged rows
merged_top_1_percent_ROH <- data.frame(CHR = character(), POS1 = integer(), POS2 = integer(), COUNT = integer(), FREQUENCY = numeric())
# Initialize a variable to store the previous row
prev_row <- NULL
# Iterate over each row in the top 1% ROH data
for (i in 1:nrow(top_1_percent_ROH)) {
# Get the current row
current_row <- top_1_percent_ROH[i, ]
# Check if it's the first row or if conditions for merging are met
if (!is.null(prev_row) && current_row$CHR == prev_row$CHR && current_row$COUNT == prev_row$COUNT && as.integer(current_row$POS1) == as.integer(prev_row$POS2) + 1) {
# Merge the current row with the previous one
prev_row$POS2 <- current_row$POS2
} else {
# If conditions for merging are not met, add the previous row to the merged dataframe
if (!is.null(prev_row)) {
merged_top_1_percent_ROH <- rbind(merged_top_1_percent_ROH, prev_row)
}
# Update the previous row to the current row
prev_row <- current_row
}
}
# Add the last row to the merged dataframe
if (!is.null(prev_row)) {
merged_top_1_percent_ROH <- rbind(merged_top_1_percent_ROH, prev_row)
}
# Calculate the length in kilobases (kb)
merged_top_1_percent_ROH$Length_kb <- (merged_top_1_percent_ROH$POS2 - merged_top_1_percent_ROH$POS1 + 1) / 1000
# Compute distance to previous and next window
merged_top_1_percent_ROH$Distance_to_prev_kb <- c(NA, diff(merged_top_1_percent_ROH$POS1)/1000)
merged_top_1_percent_ROH$Distance_to_next_kb <- c(diff(merged_top_1_percent_ROH$POS1)/1000, NA)
# Print the merged top 1% ROH data
print(merged_top_1_percent_ROH)
#max_win_gap <- 1*10^6
max_win_gap <- 2*10^6
# Initialize an empty dataframe to store linked windows
linked_windows <- data.frame(CHR = character(), POS1 = integer(), POS2 = integer(), Length_kb = numeric())
# Initialize variables to keep track of linked window
current_window <- NULL
# Iterate over each row in the merged dataframe
for (i in 1:nrow(merged_top_1_percent_ROH)) {
# Get the current row
current_row <- merged_top_1_percent_ROH[i, ]
# If it's the first row or if it's not within the specified distance from the previous window, start a new window
if (is.null(current_window) || current_row$POS1 - current_window$POS2 > max_win_gap || current_row$CHR != current_window$CHR) {
if (!is.null(current_window)) {
# Calculate Length_kb for the completed window and add it to the linked dataframe
current_window$Length_kb <- (current_window$POS2 - current_window$POS1 + 1) / 1000
linked_windows <- rbind(linked_windows, current_window[, c("CHR", "POS1", "POS2", "Length_kb")])
}
# Start a new window
current_window <- current_row
} else {
# Extend the current window
current_window$POS2 <- current_row$POS2
}
}
# Add the last window to the linked dataframe
if (!is.null(current_window)) {
current_window$Length_kb <- (current_window$POS2 - current_window$POS1 + 1) / 1000
linked_windows <- rbind(linked_windows, current_window[, c("CHR", "POS1", "POS2", "Length_kb")])
}
# Print the linked windows
print(linked_windows)
# Create scatter plots for each chromosome
for (CHR in unique(data$CHR)) {
# Subset data for the current chromosome
chr_data <- data[data$CHR == CHR, ]
chr_merged_data <- merged_top_1_percent_ROH[merged_top_1_percent_ROH$CHR == CHR, ]
# Create scatter plot
p <- ggplot() +
geom_point(data = chr_data, aes(x = POS1, y = FREQUENCY, color = "ROH-segments"), alpha = 0.5) +
geom_point(data = chr_merged_data, aes(x = POS1, y = FREQUENCY, color = "ROH hotspots"), alpha = 0.5) +
geom_hline(aes(yintercept = threshold, color = "ROH hotspot threshold"), linetype = "dashed") +
labs(title = paste("Scatter Plot for Chromosome", CHR),
x = "Position",
y = "FREQUENCY",
color = "Legend") +
scale_color_manual(values = c("ROH-segments" = "gray", "ROH hotspots" = "blue", "ROH hotspot threshold" = "red"),
labels = c("ROH-segments" = "ROH-segments", "ROH hotspots" = "ROH hotspots", "ROH hotspot threshold" = "ROH hotspot threshold")) +
theme_minimal()
# Print the plot
print(p)
}
# Define a function to split each window into two rows
split_window <- function(data) {
# Create a new dataframe to store the split rows
new_data <- data.frame(
CHR = data$CHR,
POS = c(data$POS1, data$POS2),
COUNT = rep(data$COUNT, 2),
FREQUENCY = rep(data$FREQUENCY, 2),
Length_kb = rep(data$Length_kb, 2),
Hotspot_interval = c(paste0("[", data$POS1, ",", data$POS2, "]"), paste0("[", data$POS1, ",", data$POS2, "]"))
)
return(new_data)
}
# Initialize an empty list to store the split dataframes
split_data <- list()
# Iterate over each chromosome
for (CHR in unique(merged_top_1_percent_ROH$CHR)) {
# Subset data for the current chromosome
chr_data <- merged_top_1_percent_ROH[merged_top_1_percent_ROH$CHR == CHR, ]
# Split each window into two rows
split_data[[CHR]] <- split_window(chr_data)
}
# Combine all split dataframes into one
split_data_combined <- do.call(rbind, split_data)
# Export the combined split dataframe to TSV files for each chromosome
for (CHR in unique(merged_top_1_percent_ROH$CHR)) {
# Subset the split data for the current chromosome
chr_split_data <- split_data_combined[split_data_combined$CHR == CHR, ]
# Define the filename with the output directory path
filename <- file.path(output_dir_roh_hotspots_freq, paste("chr", CHR, "_ROH_Hotspot_freq.tsv", sep = ""))
# Create the directory if it doesn't exist
dir.create(dirname(filename), recursive = TRUE, showWarnings = FALSE)
# Write data to TSV file without quotes and with tab separation
write.table(chr_split_data, file = filename, sep = "\t", row.names = FALSE, quote = FALSE)
}
# Define a function to split each window into two rows
split_window <- function(data) {
# Create a new dataframe to store the split rows
new_data <- data.frame(
CHR = data$CHR,
POS = c(data$POS1, data$POS2),
COUNT = rep(data$COUNT, 2),
FREQUENCY = rep(data$FREQUENCY, 2)
)
return(new_data)
}
# Initialize an empty list to store the split dataframes
split_data <- list()
# Iterate over each chromosome
for (CHR in unique(data$CHR)) {
# Subset data for the current chromosome
chr_data <- data[data$CHR == CHR, ]
# Split each window into two rows
split_data[[CHR]] <- split_window(chr_data)
}
# Combine all split dataframes into one
split_data_combined <- do.call(rbind, split_data)
# Export the combined split dataframe to TSV files for each chromosome
for (CHR in unique(data$CHR)) {
# Subset the split data for the current chromosome
chr_split_data <- split_data_combined[split_data_combined$CHR == CHR, ]
# # Define the filename
# filename <- paste("Chr", CHR, "_threshold_", threshold, "_ROH_freq.tsv", sep = "")
# Define the filename with the output directory path
filename <- file.path(output_dir_all_chr_roh_freq, paste("chr", CHR,"_ROH_freq", "_threshold_", threshold,".tsv", sep = ""))
# Create the directory if it doesn't exist
dir.create(dirname(filename), recursive = TRUE, showWarnings = FALSE)
# Write data to TSV file without quotes and with tab separation
write.table(chr_split_data, file = filename, sep = "\t", row.names = FALSE, quote = FALSE)
}
# Iterate over unique chromosomes
for (chr in unique(linked_windows$CHR)) {
# Subset data for the current chromosome
chr_data <- linked_windows[linked_windows$CHR == chr, c("CHR", "POS1", "POS2")]
# Define the filename with the output directory path
filename <- file.path(output_dir_gosling_plots, paste("chr",chr, "_ROH_Hotspot_windows.bed", sep = ""))
# Create the directory if it doesn't exist
dir.create(dirname(filename), recursive = TRUE, showWarnings = FALSE)
# Write data to .bed file
write.table(chr_data, file = filename, sep = "\t", quote = FALSE, col.names = FALSE, row.names = FALSE)
# Print message indicating successful export
cat("Exported", nrow(chr_data), "rows to", filename, "\n")
}
# Iterate over unique chromosomes
for (chr in unique(linked_windows$CHR)) {
# Subset data for the current chromosome
chr_data <- linked_windows[linked_windows$CHR == chr, c("CHR", "POS1", "POS2")]
# Define the filename with the output directory path
filename <- file.path(output_dir_gosling_plots, paste("chr",chr, "_ROH_Hotspot_windows.bed", sep = ""))
# Create the directory if it doesn't exist
dir.create(dirname(filename), recursive = TRUE, showWarnings = FALSE)
# Write data to .bed file
write.table(chr_data, file = filename, sep = "\t", quote = FALSE, col.names = FALSE, row.names = FALSE)
# Print message indicating successful export
cat("Exported", nrow(chr_data), "hotspot windows to", filename, "\n")
}
