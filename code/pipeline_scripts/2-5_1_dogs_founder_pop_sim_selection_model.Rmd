---
title: "Selection Scenario simulation for Dogs in AlphaSimR"
output:
  html_document:
    toc: true
    toc_depth: 3  
date: "2024-05-19"
editor_options: 
  markdown: 
    wrap: 72
---

# 0: Preparation

## Defining the output directory & the chromosome to be simulated

```{r}
# Clean the working environment
rm(list = ls())

knitr::opts_chunk$set(echo = TRUE)

#################################### 
# Defining Input parameters
#################################### 

min_MAF <- 0.05 #(minimum allowed Minor Allele Frequency for each SNP)
allele_copies_threshold <- 10 # 10 default (candidate_variants = less than 10)
min_allowed_gen_before_variant_lost <- 10 # Pruning replicates where the causative variant gets lost within this timespan
N_e_burn_in <- 2500 # Ancestral population
N_e_bottleneck <- 50
N_e_mate_selection <- 50


n_generations_bottleneck <- 5
#################################### 
# Defining the output files
#################################### 
print("R script started executing")


s <- as.numeric(Sys.getenv("selection_coefficient")) # using as.numeric, otherwise class(s) = "character"
# Print the value of selection_coefficient
cat("Selection Coefficient:", s, "\n")

#print(Sys.getenv("selection_coefficient"))


n_generations_mate_selection <-  as.numeric(Sys.getenv("n_generations_selection_sim"))  # using as.numeric, otherwise class(n_generations_selection_sim) = "character"
n_generations_mate_selection

n_ind_per_selection_sim_generation <- as.numeric(Sys.getenv("n_ind_per_selection_sim_generation")) # using as.numeric, otherwise class(n_ind_per_selection_sim_generation) = "character"


# Define the output directory based on the variable passed from the Bash script
output_dir_simulation <- Sys.getenv("output_dir_selection_simulation")
output_dir_simulation
image_output_dir <- paste0(output_dir_simulation, "/variant_freq_plots")
chr_simulated <- Sys.getenv("chr_simulated")
chr_simulated
output_sim_files_basename <- Sys.getenv("output_sim_files_basename")
simulation_prune_count_file <- Sys.getenv("simulation_prune_count_file")
snp_density_Mb <- as.numeric(Sys.getenv("selected_chr_snp_density_mb")) 



# Ensure that output_dir_simulation is defined
if (is.null(output_dir_simulation)) {
  stop("output_dir_simulation is not provided.")
}

Sys.getenv()
# # Verify the current working directory
#getwd()
```

## Loading libraries

```{r library()}
library(AlphaSimR)
library(knitr)

```

# 1: Creating founder Haplotypes

## 1.0: Defining chromosome lengths of model species

```{r}
# Chromosome lengths of Dogs in Mb, derived from Table 1 in this article:
# https://www-ncbi-nlm-nih-gov.ezproxy.its.uu.se/pmc/articles/PMC2564286/

chromosome_lengths_mb <- c(
    "chr1" = 125, "chr2" = 88, "chr3" = 94, "chr4" = 91, "chr5" = 91,
    "chr6" = 80, "chr7" = 83, "chr8" = 77, "chr9" = 64, "chr10" = 72,
    "chr11" = 77, "chr12" = 75, "chr13" = 66, "chr14" = 63, "chr15" = 67,
    "chr16" = 62, "chr17" = 67, "chr18" = 58, "chr19" = 56, "chr20" = 61,
    "chr21" = 54, "chr22" = 64, "chr23" = 55, "chr24" = 50, "chr25" = 54,
    "chr26" = 42, "chr27" = 48, "chr28" = 44, "chr29" = 44, "chr30" = 43,
    "chr31" = 42, "chr32" = 41, "chr33" = 34, "chr34" = 45, "chr35" = 29,
    "chr36" = 33, "chr37" = 33, "chr38" = 26
)
```

## 1.1: runMacs2() - Generating founder population

`runMacs2` Parameters:

-   nInd = 100: 100 individuals in the founder population

-   nChr = 1: Haplotypes are created for 1 chromosome per individual

-   Ne = 2500: Effective population size: 2500 (Ne)

-   bp: base pair length of chromosome

-   genLen = 1: Genetic length of chromosome in Morgans, set as 1.

-   HistNe = NULL: No effective population size defined from previous
    generations (histNe = NULL)

-   histGen = NULL: If HistNe was defined, this parameter would define
    the number of generations ago we had the Ne defined in HistNe

```{r runMacs2()}
#help(runMacs2)

model_chromosome_bp_length <- chromosome_lengths_mb[chr_simulated] * 10^6

founderGenomes <- runMacs2(nInd = 100,
                     nChr = 1,
                     Ne = N_e_burn_in,
                     bp = model_chromosome_bp_length,
                     genLen = 1,
                     histNe = NULL,
                     histGen = NULL)

# Inspecting the founderGenomes object
founderGenomes

```

## 1.2: SimParam() - Setting Global Simulation Parameters

```{r SimParam()}

#help(SimParam)

# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP

```

### 1.2.1: \$setTrackRec() - Setting on recombination tracking for the simulation

Sets recombination tracking for the simulation. By default recombination
tracking is turned off. **When turned on recombination tracking will
also turn on pedigree tracking.**

**Recombination tracking keeps records of all individuals created,**
except those created by hybridCross, because their pedigree is not
tracked.

```{r SimParam$setTrackRec()}
SP$setTrackRec(TRUE)
```

## 1.3: newPop() - Creating two separate populations for bottleneck event

```{r newPop()}
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# Set misc used for setting years of birth for the first individuals
current_generation = 0
founderpop = setMisc(x = founderpop,
                   node = "generation",
                   value = current_generation)
head(getMisc(x = founderpop, node = "generation"))

# Split the founder population into two breeding groups
breed1_founders <- founderpop[1:N_e_bottleneck] # 1:50
cat("Population 1:\n")
breed1_founders

breed2_founders <- founderpop[(N_e_bottleneck + 1):(2 * N_e_bottleneck)] # 51:100
cat("Population 2:\n")
breed2_founders

```

# 2: Forward in time simulation

## 2.1: Bottleneck Simulation for 5 Generations - randCross()

`randCross()` simulates random mating.

-   **nCrosses**-argument specifies how many times an individual in the
    population can be a parent. In this case, an individual can only be
    a parent once (random mating)

-   **nProgeny**-argument specifies how many progeny's each mating pair
    can have. In this case, this parameter is set at 1 progeny per
    mating pair.

-   **simParam**-argument specifies the global simulation parameters

```{r}
random_mating <- function(pop, SP, n_gen) {
    n_ind <- pop@nInd # Extracting number of individuals in the current population
    generations <- vector(length = n_gen + 1,
                          mode = "list")
    generations[[1]] <- pop # The initial breeding group population gets stored as the first element

    # Simulating randomm mating to perform simulation of the 2nd until the n+1:th generation
    # Each mating Progenys are generated using randcross
    for (gen_ix in 2:(n_gen + 1)) {
        generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
                                           simParam = SP)
    }
     bottleneck_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)

    return(bottleneck_generations)
}


# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP,n_generations_bottleneck)
breed2_bottleneck <- random_mating(breed2_founders, SP,n_generations_bottleneck)
```

### 2.1.1 Extracting the final bottleneck generation

```{r}

# Viewing the output

# founders
founderpop
breed1_bottleneck


# Extracting final generation:
last_bottleneck_generation <- breed1_bottleneck[[n_generations_bottleneck]]

cat("Extracting the final generation from the Bottleneck Scenario")
last_bottleneck_generation
```
## 2.2: Adding SNPs to the final bottleneck generation ( SimParam\$addSnpChip())

### 2.2.1 Single chromosome usage: Computing number of SNPs to assign to a chromosome

```{r}

 # Sum up the chromosome lengths to get the autosome length
 autosome_length <- sum(chromosome_lengths_mb)

 # Number of SNP markers from the empirical dataset
 # https://datadryad.org/stash/dataset/doi:10.5061/dryad.h44j0zpkf
 num_snp_markers <- 78088

 # Calculate average SNP-autosome density
 average_snp_autosome_density <- num_snp_markers / autosome_length

 # Calculate the number of SNP markers to choose for the specific chromosome
 num_snp_markers_chr3 <- average_snp_autosome_density * chromosome_lengths_mb[chr_simulated]



 # Output results
 cat("autosome length:", autosome_length, "Mb\n")
 cat("Average SNP-autosome density:", average_snp_autosome_density, "SNPs/Mb\n")
 cat("Number of SNP markers for", chr_simulated, ":", num_snp_markers_chr3, "SNPs\n")

```

```{r}
 average_chr_SNP_density <- num_snp_markers / length(chromosome_lengths_mb)
 cat(" Average Chr SNP density:", average_chr_SNP_density, "SNPs/Chr\n")
```

### 2.1.2: SimParam\$addSnpChip() - Randomly assigns eligible SNPs to a SNP chip

`SP$addSnpChip()`Randomly assigns eligible SNPs to a SNP chip.

**nSnpPerChr**-argument that assigns for each individuals n SNPs for
each chromsome, where n is the user-specified number.

**minSnpFreq**-argument sets the Minimum Allele Frequency (MAF) allowed
for each marker. For instance, setting minSnpFreq = 0.05 ensures that
all markers will have MAF \>= 0.05

**refPop**-argument specifies which population will be genotyped. In
this case, it will be the last_generation after the simulated population
bottleneck scenario.

```{r SimParam$addSnpChip()}
model_chromosome_Mb_length <- chromosome_lengths_mb[chr_simulated]

num_snp_markers_simulated_chromosome <- snp_density_Mb * model_chromosome_Mb_length
num_snp_markers_simulated_chromosome

SP$addSnpChip(
  nSnpPerChr = num_snp_markers_simulated_chromosome,
  minSnpFreq = min_MAF,
  refPop = last_bottleneck_generation
  )
```
## 2.4 Simulating the selection scenario - makeCross()

`makeCross()` Parameters:

## 2.4.1 Choosing a causative variant for the Selection Scenario - find_causative_variant()
```{r}
find_causative_variant <- function(population,SP, allele_copies_threshold) {
  # Count occurrences of each variant
  count <- colSums(pullSegSiteGeno(population, simParam = SP))
  
  # Find candidate variants (less than or equal to the threshold)
  candidate_variants <- which(count <= allele_copies_threshold)
  
  # Randomly pick one of the candidate variants as the causative variant
  causative_variant <- candidate_variants[sample(1:length(candidate_variants), 1)]
  
  return(causative_variant)
}
```


### 2.4.2 Defining the Mate selection function - Mate_Selection_scenario()

```{r}

Mate_Selection_scenario <- function(selection_scenario_pop, n_generations_mate_selection, causative_variant, s, n_ind_per_selection_sim_generation,SP) {
  
  # Creating a vector to store the allele frequency of the causative variant over the selection simulation generations
  f_causative <- numeric(n_generations_mate_selection)
    
  # Loop through generations
  for (gen in 1:n_generations_mate_selection) {
    
    # Retrieves the genotype of the causative variant for each individual in the population  
    geno <- pullSegSiteGeno(selection_scenario_pop, simParam = SP)[, causative_variant]
    # cat("\nGeneration", gen, "Geno:",geno)  
    
    #     # Print out the genotype of each individual
    # for (i in 1:length(geno)) {
    #   if (geno[i] == 2) {
    #     cat("Generation", gen, "- Individual", i, "is homozygous for the causative variant (AA)\n")
    #   } else if (geno[i] == 1) {
    #     cat("Generation", gen, "- Individual", i, "is heterozygous (Aa)\n")
    #   } else if (geno[i] == 0) {
    #     cat("Generation", gen, "- Individual", i, "is homozygous for the non-causative variant (aa)\n")
    #   }
    # }
    
    # Set fitness based on genotype
    fitness <- rep(1-s, length(geno))
    fitness[geno == 2] <- 1
    fitness[geno == 1] <- 1 - (s/2)
    
    # Biased sampling of parents based on fitness
    parent1 <- sample(1:selection_scenario_pop@nInd, n_ind_per_selection_sim_generation, replace = TRUE, prob = fitness)
    parent2 <- sample(1:selection_scenario_pop@nInd, n_ind_per_selection_sim_generation, replace = TRUE, prob = fitness)
    
    # Crossing parents to create next generation
    selection_scenario_pop <- makeCross(selection_scenario_pop,
                                        cbind(parent1, parent2),
                                        nProgeny = 1,
                                        simParam = SP)
    
    # Introduce mutations to the new generation
    selection_scenario_pop <- AlphaSimR::mutate(selection_scenario_pop, simParam = SP)
    
    # Calculate allele frequency of the causative variant
    f_causative[gen] <- sum(geno) / length(geno) / 2
  }
  
  return(list(f_causative,selection_scenario_pop))
  
}

```
### 2.4.3 Simulating the selection scenario - makeCross()
```{r} 
setwd(image_output_dir)
# Create a counter for tracking the amount of pruned replicates 
# due to the causatative variant getting lost within min_allowed_gen_before_variant_lost generations
disappearance_counter <- 0

# Define the rerun mechanism
success <- FALSE
while (!success) {
  
  # Function to randomly pick out a causative variant to be studied
  causative_variant <- find_causative_variant(last_bottleneck_generation, SP, allele_copies_threshold)
  # Print the chosen causative variant
  paste("Variant chosen:", causative_variant)

  # Sets the initial population for the selection scenario to the last generation of the bottleneck simulation.
  selection_scenario_pop <- last_bottleneck_generation
  
  # Run the simulation, starting with the last generation of the bottleneck simulation as 
  # The initial population for the selection scenario
  result <- Mate_Selection_scenario(selection_scenario_pop, n_generations_mate_selection, causative_variant, s, n_ind_per_selection_sim_generation, SP)
  
  f_causative <- result[[1]]
    
  # Check if the causative variant disappeared  
  if (f_causative[min_allowed_gen_before_variant_lost] > 0) {
    success <- TRUE
    last_mate_selection_generation <- result[[2]]

  } else {
    cat("Causative variant disappeared, rerunning simulation...\n")
    cat("f_causative:", f_causative, "\n")
    
    # Increment the pruned replicates counter
    disappearance_counter <- disappearance_counter + 1
  }
  
}




f_causative

# Plotting the allele frequency of the causative variant during the mate selection scenario

# Open a PNG graphics device with the desired filename
png(paste0(output_sim_files_basename, '.png'))

# Set the plot title
plot_title <- sprintf("Causative-Variant Frequency Plot - s=%g (%d replicates pruned) ", s, disappearance_counter)


# Plot with customized axes labels and title
plot(f_causative,
     type = "p",
     xlab = "Generation",
     ylab = "Allele Frequency ",
     main = plot_title,
     ylim = c(0, 1)
     )



# # Save the plot
dev.off()

```

```{r}
#last_mate_selection_generation <- selection_scenario_pop[[n_generations_mate_selection]]

cat("Population before the selection scenario simulation:\n")
last_bottleneck_generation
cat("\nPopulation after",n_generations_mate_selection,"generations of selection scenario simulation:\n")
last_mate_selection_generation

```
<!-- ## 2.5: Adding SNPs to the final bottleneck generation ( SimParam\$addSnpChip()) -->

<!-- ### 2.5.1 Single chromosome usage: Computing number of SNPs to assign to a chromosome -->

<!-- ```{r} -->

<!-- # Sum up the chromosome lengths to get the autosome length -->
<!-- autosome_length <- sum(chromosome_lengths_mb) -->

<!-- # Number of SNP markers from the empirical dataset -->
<!-- # https://datadryad.org/stash/dataset/doi:10.5061/dryad.h44j0zpkf -->
<!-- num_snp_markers <- 78088 -->

<!-- # Calculate average SNP-autosome density -->
<!-- average_snp_autosome_density <- num_snp_markers / autosome_length -->

<!-- # Calculate the number of SNP markers to choose for the specific chromosome -->
<!-- num_snp_markers_chr3 <- average_snp_autosome_density * chromosome_lengths_mb[chr_simulated] -->



<!-- # Output results -->
<!-- cat("autosome length:", autosome_length, "Mb\n") -->
<!-- cat("Average SNP-autosome density:", average_snp_autosome_density, "SNPs/Mb\n") -->
<!-- cat("Number of SNP markers for", chr_simulated, ":", num_snp_markers_chr3, "SNPs\n") -->

<!-- ``` -->

<!-- ```{r} -->
<!-- average_chr_SNP_density <- num_snp_markers / length(chromosome_lengths_mb) -->
<!-- cat(" Average Chr SNP density:", average_chr_SNP_density, "SNPs/Chr\n") -->

<!-- ``` -->

<!-- ### 2.5.2: SimParam\$addSnpChip() - Randomly assigns eligible SNPs to a SNP chip -->

<!-- `SP$addSnpChip()`Randomly assigns eligible SNPs to a SNP chip. -->

<!-- **nSnpPerChr**-argument that assigns for each individuals n SNPs for -->
<!-- each chromsome, where n is the user-specified number. -->

<!-- **minSnpFreq**-argument sets the Minimum Allele Frequency (MAF) allowed -->
<!-- for each marker. For instance, setting minSnpFreq = 0.05 ensures that -->
<!-- all markers will have MAF \>= 0.05 -->

<!-- **refPop**-argument specifies which population will be genotyped. In -->
<!-- this case, it will be the last_mate_selection_generation after the simulated population -->
<!-- bottleneck scenario. -->

<!-- ```{r SimParam$addSnpChip()} -->
<!-- SP$addSnpChip( -->
<!--   nSnpPerChr = num_snp_markers_chr3, -->
<!--   minSnpFreq = min_MAF, -->
<!--   refPop = last_mate_selection_generation -->
<!--   ) -->
<!-- ``` -->


# 3: Export to PLINK Extracting data to PLINK

## 3.0.1: Optional: pullSnpGeno() - Retrieves a list of the existing marker id:s (SNP id:s)

Function that retrieves SNP genotype data & returns a matrix of SNP
genotypes

```{r pullSnpGeno(), echo = FALSE}
#pullSnpGeno(last_generation,simParam=SP)
```

## 3.0.2: Optional: getSnPMap() - Retrieves a table of the genetic map

Function that retrieves the genetic map for a given SNP chip & returns a
data.frame with:

-   **id:** Unique identifier for the marker (SNP)

-   **chr:** Chromosome containing the SNP

-   **site:** Segregating site on the chromosome

-   **pos:** Genetic map position

```{r getSnPMap()}
# SP$addSnpChip(5)
# getSnpMap(snpChip=1,simParam=SP)

#getSnpMap(simParam=SP)

cat("First 10 markers and their genetic map positions:\n")
kable(head(getSnpMap(simParam = SP), 10))
#head(getSnpMap(simParam = SP), 10)


```

## 3.1: writePlink()

**Description** Function that inputs a Pop-class & exports it to PLINK
PED and MAP files.

The arguments for this function were chosen for consistency with
RRBLUP2. **The base pair coordinate will the locus position as stored in
AlphaSimR** & not an actual base pair position, because AlphaSimR
doesn’t track base pair positions, **only relative positions for the
loci used in the simulation**.

\*\* Usage \*\* writePlink( pop, baseName, traits = 1, use = "pheno",
snpChip = 1, useQtl = FALSE, simParam = NULL, ... )

**Arguments:**

-   **pop** an object of Pop-class

-   **baseName** basename for PED and MAP files.

-   **traits** an integer indicating the trait to write, a trait name,
    or a function of the traits returning a single value.

-   **use** what to use for PLINK’s phenotype field. Either phenotypes
    "pheno", genetic values "gv", estimated breeding values "ebv",
    breeding values "bv", or random values "rand".

-   **snpChip** an integer indicating which SNP chip genotype to use
    useQtl should QTL genotypes be used instead of a SNP chip.

    ```
       -    If TRUE, snpChip specifies which trait’s QTL to use, and thus these QTL may not match the QTL underlying the phenotype supplied in traits.
    ```

-   **simParam** an object of SimParam ... additional arguments if using
    a function for traits

```{r}
# Setting the directory where the .map and .ped files will be stored in
setwd(output_dir_simulation)

writePlink(last_mate_selection_generation,simParam=SP, baseName=output_sim_files_basename,

            traits = 1,
           use = "rand"


           )
```

# 4: Convert distances to basepair in the .map file

```{r}
# Setting the working directory as the output directory
setwd(output_dir_simulation)

# Read PLINK files into R objects
ped_file <- paste0(output_sim_files_basename, '.ped')
map_file <- paste0(output_sim_files_basename, '.map')
ped_data <- read.table(ped_file)
map_data <- read.table(map_file)


genetic_distance_morgan_column <- map_data$V3 # Extracting the genetic distance column of map_data (3rd column)
base_pair_position_column <- round(genetic_distance_morgan_column * (model_chromosome_bp_length / 100))

# Redefining the physical position column (4th column) with the new values defined in base_pair_position_column
map_data$V4 <- base_pair_position_column

write.table(map_data, file = map_file, sep = "\t", row.names = FALSE, col.names = FALSE,quote = FALSE)

#col.names = FALSE: Removes the header.
#quote = FALSE: Removes quotation marks from values.


cat("Showing the first 10 rows of the new .map file:\n")
kable(head(map_data, 10))

# Print the number of times the causative variant disappeared
cat("Number of times the causative variant disappeared:\n")

cat("Disappearance Counter:", disappearance_counter, "\n")  # Print disappearance_counter value to standard output

```

# 4: ExportConvert distances to basepair in the .map file
```{r}

# Check if the file exists
if (file.exists(simulation_prune_count_file)) {
    # Read the existing data from the file
    prune_count_data <- read.table(simulation_prune_count_file, header = FALSE, sep = "\t")
} else {
    # Create an empty data frame if the file does not exist
    prune_count_data <- data.frame(V1 = character(), V2 = integer())
}

# Create a new row with the output_sim_files_basename and disappearance_counter
new_row <- data.frame(V1 = output_sim_files_basename, V2 = disappearance_counter)

# Append the new row to the existing data
prune_count_data <- rbind(prune_count_data, new_row)

# Write the updated data back to the file
write.table(prune_count_data, file = simulation_prune_count_file, sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
```
