# Clean the working environment
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
use_chromosome_specific_recombination_rate <- as.logical("TRUE")
# use_chromosome_specific_recombination_rate <- as.logical("FALSE")
####################################
# Defining the working directory
####################################
# Set the path to your GitHub folder
YOUR_GITHUB_ROOT_DIRECTORY <- "C:/Users/jonat/GitHub"
# Defining the relative path in the repository
repository_path <- "Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations"
output_dir_simulation <- file.path(YOUR_GITHUB_ROOT_DIRECTORY, repository_path,"data/raw/simulated/neutral_model")
if (!dir.exists(output_dir_simulation)) {
# Create the working directory if it doesn't exist
dir.create(output_dir_simulation, recursive = TRUE)
}
# # Set the working directory for notebook chunks
# knitr::opts_knit$set(root.dir = output_dir_simulation)
####################################
# Defining Input parameters
####################################
# min_MAF <- 0.05 #(minimum allowed Minor Allele Frequency for each SNP)
chr_simulated <- "chr3"
# Extract the chromosome number and convert and convert it to numeric
chr_number <- as.numeric(sub("chr", "", chr_simulated))
N_e_burn_in <- 125
n_bottleneck <- 100
Inbred_ancestral_population <- as.logical("FALSE")
# Inbred_ancestral_population <- as.logical("TRUE")
n_generations_bottleneck <- 14
n_generations_random_mating <- 60
n_indv_breed_formation <- 650
Ref_pop_snp_chip <- "last_breed_formation_generation"
# Ref_pop_snp_chip <- "last_bottleneck_generation"
# introduce_mutations <- as.logical("FALSE")
introduce_mutations <- as.logical("TRUE")
snp_density_Mb <- 91.23
snp_density_Mb
####################################
# Defining the output files
####################################
# Define the base name for the output .map & .ped PLINK files
output_sim_files_basename <- paste0("Neutral_simulation_", chr_simulated)
# # Verify the current working directory
#getwd()
# Check and install AlphaSimR if it's not already installed
if (!require(AlphaSimR)) {
install.packages("AlphaSimR", dependencies = TRUE)
}
library(AlphaSimR)
# Check and install knitr if it's not already installed
if (!require(knitr)) {
install.packages("knitr", dependencies = TRUE)
}
library(knitr)
# Check and install rmarkdown if it's not already installed
if (!require(rmarkdown)) {
install.packages("rmarkdown", dependencies = TRUE)
}
library(rmarkdown)
chromosome_lengths_bp <- c(
"chr1" = 123556469, "chr2" = 84979418, "chr3" = 92479059, "chr4" = 89535178	, "chr5" = 89562946,
"chr6" = 78113029	, "chr7" = 81081596, "chr8" = 76405709, "chr9" = 61171909, "chr10" = 70643054,
"chr11" = 74805798, "chr12" = 72970719, "chr13" = 64299765, "chr14" = 61112200, "chr15" = 64676183,
"chr16" = 60362399, "chr17" = 65088165, "chr18" = 56472973, "chr19" = 55516201, "chr20" = 58627490,
"chr21" = 51742555, "chr22" = 61573679, "chr23" = 53134997, "chr24" = 48566227, "chr25" = 51730745,
"chr26" = 39257614, "chr27" = 46662488, "chr28" = 41733330, "chr29" = 42517134, "chr30" = 40643782,
"chr31" = 39901454, "chr32" = 40225481, "chr33" = 32139216, "chr34" = 42397973, "chr35" = 28051305,
"chr36" = 31223415, "chr37" = 30785915, "chr38" = 24803098
)
chromosome_recombination_rates_cM_Mb <- c(
"chr1" = 0.68, "chr2" = 0.88, "chr3" =0.69, "chr4" = 0.75, "chr5" = 0.85,
"chr6" = 0.71, "chr7" = 0.75 , "chr8" = 0.83, "chr9" = 1.11, "chr10" = 0.78,
"chr11" = 0.84, "chr12" = 0.87, "chr13" = 0.90, "chr14" = 0.89, "chr15" = 0.80,
"chr16" = 0.90, "chr17" = 0.89, "chr18" = 0.88, "chr19" = 0.93, "chr20" = 0.93,
"chr21" = 1.02, "chr22" = 0.84, "chr23" = 1.02, "chr24" = 1.13, "chr25" = 1.05,
"chr26" = 1.22, "chr27" = 1.18, "chr28" =1.31, "chr29" = 1.15, "chr30" = 1.36,
"chr31" = 1.29, "chr32" = 1.37, "chr33" = 1.53, "chr34" = 1.17, "chr35" = 2.15,
"chr36" = 1.54, "chr37" = 1.38, "chr38" = 2.22
)
# Extracting the physical length of the simulated chromosome
model_chromosome_physical_length_bp <- chromosome_lengths_bp[chr_simulated]
if (use_chromosome_specific_recombination_rate) {
# Extracting the recombination rate of the simulated chromosome
model_chromosome_recombination_rate <- chromosome_recombination_rates_cM_Mb[chr_simulated]
# Computing the genetic length of the simulated chromosome
model_chromosome_genetic_length_morgan <- (model_chromosome_physical_length_bp*10^-6)*(model_chromosome_recombination_rate*10^-2)
model_chromosome_genetic_length_morgan
} else {
# Setting the average recombination rate for dogs.
average_recombination_rate <- 0.97
# Computing the genetic length of the simulated chromosome
model_chromosome_genetic_length_morgan <- (model_chromosome_physical_length_bp*10^-6)*(average_recombination_rate*10^-2)
model_chromosome_genetic_length_morgan
}
#help(runMacs2)
mutation_rate <- 1*10^-8
founderGenomes <- runMacs2(nInd = n_bottleneck ,
nChr = 1,
Ne = N_e_burn_in,
bp = model_chromosome_physical_length_bp,
inbred = Inbred_ancestral_population,
genLen = model_chromosome_genetic_length_morgan,
mutRate = mutation_rate,
histNe = NULL,
histGen = NULL)
# Inspecting the founderGenomes object
founderGenomes
#help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
SP$setTrackRec(TRUE)
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# # Set misc used for setting years of birth for the first individuals
# current_generation = 0
# founderpop = setMisc(x = founderpop,
#                    node = "generation",
#                    value = current_generation)
# head(getMisc(x = founderpop, node = "generation"))
# Split the founder population into two breeding groups
# breed1_founders <- founderpop # 1:50
breed1_founders <- founderpop[1:n_bottleneck] # 1:50
cat("Population 1:\n")
breed1_founders
# breed2_founders <- founderpop[51:100]
# breed2_founders
random_mating_bottleneck <- function(pop, SP, n_gen,n_bottleneck,introduce_mutations,mutation_rate) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1,
mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating random mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
# Initialize vectors for parents
parent1 <- integer(n_bottleneck)
parent2 <- integer(n_bottleneck)
# Create mating pairs
for (i in 1:n_bottleneck) {
# Sample parent1
parent1[i] <- sample(1:generations[[gen_ix - 1]]@nInd, 1)
# Ensure parent2 is different from parent1
repeat {
parent2[i] <- sample(1:generations[[gen_ix - 1]]@nInd,1)
if (parent2[i] != parent1[i]) break
}
}
# Crossing parents to create next generation
generations[[gen_ix]] <- makeCross(generations[[gen_ix - 1]],
cbind(parent1, parent2),
nProgeny = 1,
simParam = SP)
# Introducing mutations
if (introduce_mutations == TRUE) {
generations[[gen_ix]] <- AlphaSimR::mutate(generations[[gen_ix]],mutRate = mutation_rate, simParam = SP)
}
}
random_mating_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
return(random_mating_generations)
}
random_mating_breed_formation <- function(pop, SP, n_gen,n_indv_breed_formation,introduce_mutations,mutation_rate) {
# n_indv_breed_formation <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1,
mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating random mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
# Initialize vectors for parents
parent1 <- integer(n_indv_breed_formation)
parent2 <- integer(n_indv_breed_formation)
# Create mating pairs
for (i in 1:n_indv_breed_formation) {
# Sample parent1
parent1[i] <- sample(1:generations[[gen_ix - 1]]@nInd, 1, replace = TRUE)
# Ensure parent2 is different from parent1
repeat {
parent2[i] <- sample(1:generations[[gen_ix - 1]]@nInd,1, replace = TRUE)
if (parent2[i] != parent1[i]) break
}
}
# Crossing parents to create next generation
generations[[gen_ix]] <- makeCross(generations[[gen_ix - 1]],
cbind(parent1, parent2),
nProgeny = 1,
simParam = SP)
# Introducing mutations
if (introduce_mutations == TRUE) {
generations[[gen_ix]] <- AlphaSimR::mutate(generations[[gen_ix]],mutRate = mutation_rate, simParam = SP)
}
}
random_mating_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
# return(random_mating_generations)
final_generation <- generations[[n_gen + 1]] # Returning only the final generation
return(final_generation)
}
if (n_generations_bottleneck > 0) {
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating_bottleneck(breed1_founders, SP, n_generations_bottleneck, n_bottleneck, introduce_mutations, mutation_rate)
}
# breed2_bottleneck <- random_mating_bottleneck(breed2_founders, SP, n_generations_bottleneck)
# Viewing the output
# founders
founderpop
if (n_generations_bottleneck == 0) {
last_bottleneck_generation <- breed1_founders
} else {
breed1_bottleneck
# Extracting final generation:
last_bottleneck_generation <- breed1_bottleneck[[n_generations_bottleneck]]
}
cat("Extracting the final generation from the Bottleneck Scenario")
last_bottleneck_generation
model_chromosome_Mb_length <- model_chromosome_physical_length_bp / (10^6)
num_snp_markers_simulated_chromosome <- snp_density_Mb * model_chromosome_Mb_length
# Convert to the closest integer
num_snp_markers_simulated_chromosome <- round(num_snp_markers_simulated_chromosome)
if (num_snp_markers_simulated_chromosome > founderGenomes@nLoci) {
cat("Reference amount of SNP markers for ",chr_simulated, ": ",num_snp_markers_simulated_chromosome)
cat("\n",num_snp_markers_simulated_chromosome," > ",founderGenomes@nLoci)
cat("\n Burn in N_e: ", N_e_burn_in,"\n")
num_snp_markers_simulated_chromosome <- founderGenomes@nLoci
new_SNP_density <- num_snp_markers_simulated_chromosome / model_chromosome_Mb_length
cat("\n Old SNP density: ",snp_density_Mb," markers/Mb")
cat("\n New SNP density: ",new_SNP_density," markers/Mb")
} else {
cat("Reference amount of SNP markers for ",chr_simulated, ": ",num_snp_markers_simulated_chromosome)
cat("\n",num_snp_markers_simulated_chromosome," < ",founderGenomes@nLoci)
cat("\n Burn in N_e: ", N_e_burn_in,"\n")
}
# Check if Ref_pop_snp_chip is equal to last_bottleneck_generation
if (Ref_pop_snp_chip == "last_bottleneck_generation") {
SP$addSnpChip(nSnpPerChr = num_snp_markers_simulated_chromosome,
refPop = last_bottleneck_generation
)
}
last_random_mating_generation <- random_mating_breed_formation(last_bottleneck_generation, SP, n_generations_random_mating,n_indv_breed_formation,introduce_mutations,mutation_rate)
# Check if Ref_pop_snp_chip is equal to "last_breed_formation_generation"
if (Ref_pop_snp_chip == "last_breed_formation_generation") {
SP$addSnpChip(nSnpPerChr = num_snp_markers_simulated_chromosome,
refPop = last_random_mating_generation
)
}
#pullSnpGeno(last_random_mating_generation,simParam=SP)
# SP$addSnpChip(5)
# getSnpMap(snpChip=1,simParam=SP)
#getSnpMap(simParam=SP)
cat("First 10 markers and their genetic map positions:\n")
kable(head(getSnpMap(simParam = SP), 10))
#head(getSnpMap(simParam = SP), 10)
# Setting the directory where the .map and .ped files will be stored in
setwd(output_dir_simulation)
writePlink(last_random_mating_generation,simParam=SP, baseName=output_sim_files_basename,
traits = 1,
use = "rand"
)
# Setting the working directory as the output directory
setwd(output_dir_simulation)
# Read PLINK files into R objects
ped_file <- paste0(output_sim_files_basename, '.ped')
map_file <- paste0(output_sim_files_basename, '.map')
ped_data <- read.table(ped_file)
map_data <- read.table(map_file)
# ¤¤¤¤¤ .map-file Column 1: Changing to correct chromosome ¤¤¤¤¤
# Change the first column of the .map file to ensure that the correct chromosome number is used
map_data$V1 <- chr_number
# ¤¤¤¤¤ .map-file Column 2: Changing the SNP IDs to refer to correct chromosome ¤¤¤¤¤
# Changing the SNP_Ids (second column) so their prefix indicate the correct chromosome number, otherwise
# It  will seem like they all belong to chromosome 1, like "1_21".
# (will be useful if you one would simulate more chromosomes than one)
map_data$V2 <- gsub("^\\d+_", paste0(chr_number, "_"), map_data$V2)
# ¤¤¤¤¤ .map-file Column 4: Mapping correct bp-positions for the markers ¤¤¤¤¤
genetic_distance_morgan_column <- map_data$V3 / 100 # Extracting the genetic distance column of map_data (3rd column)
base_pair_position_column <- round( (genetic_distance_morgan_column/model_chromosome_genetic_length_morgan) * model_chromosome_physical_length_bp)
# Ensure no physical positions are 0, replacing 0 with 1
base_pair_position_column[base_pair_position_column == 0] <- 1
model_chromosome_genetic_length_morgan*10^2
max(base_pair_position_column)
# Redefining the physical position column (4th column) with the new values defined in base_pair_position_column
map_data$V4 <- base_pair_position_column
#col.names = FALSE: Removes the header.
#quote = FALSE: Removes quotation marks from values.
write.table(map_data, file = map_file, sep = "\t", row.names = FALSE, col.names = FALSE,quote = FALSE)
cat("Showing the first 10 rows of the new .map file:\n")
kable(head(map_data, 10))
