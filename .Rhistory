return(last_generation)
}
# Example usage
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1, mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating random mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop = generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
last_generation <- generations[[n_gen + 1]]
if (length(last_generation@id) > 0) {
last_generation <- data.frame(
id = last_generation@id,
father = last_generation@father,
mother = last_generation@mother,
sex = last_generation@sex,
generation = unlist(getMisc(x = last_generation, node = "generation")),
generation_progeny = n_gen
)
} else {
warning("No individuals in the last generation.")
last_generation <- NULL  # or data.frame() if you prefer an empty data frame
}
return(last_generation)
}
# Example usage
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
# Clean the working environment
rm(list = ls())
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
setwd()
setwd(C:\Users\jonat\GitHub\Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations)
setwd(C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations)
setwd(/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations)
setwd(GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations)
setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
# # Change working directory
# setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
help(runMacs2)
founderGenomes <- runMacs2(nInd = 100,
nChr = 1,
Ne = 2500,
histNe = NULL,
histGen = NULL)
# Inspecting the founderGenomes object
founderGenomes
help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
SP$addTraitA(nQtlPerChr = 10) # Trait 1 is affected by 10 QTL/chromosme
# Inspecting the traits element of the SB object
SP$traits
SP$setSexes("yes_sys")
SP$setVarE(h2 = 0.2)
SP$addSnpChip(nSnpPerChr = 1000)
SP$setTrackRec(TRUE)
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# Set misc used for setting years of birth for the first individuals
current_generation = 0
founderpop = setMisc(x = founderpop,
node = "generation",
value = current_generation)
head(getMisc(x = founderpop, node = "generation"))
# Split the founder population into two breeding groups
breed1_founders <- founderpop[1:50]
breed1_founders
breed2_founders <- founderpop[51:100]
breed2_founders
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1,
mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating randomm mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
bottleneck_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
return(bottleneck_generations)
}
n_generations <- 5
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, n_generations)
breed2_bottleneck <- random_mating(breed2_founders, SP, n_generations)
# founders
founderpop
breed1_bottleneck
# founders
founderpop
breed1_bottleneck
# Extracting final generation:
last_generation <- breed1_bottleneck [[n_generations + 1]]
# Extracting final generation:
last_generation <- breed1_bottleneck[n_generations + 1]
last_generation
# founders
founderpop
breed1_bottleneck
# Extracting final generation:
last_generation <- breed1_bottleneck[n_generations]
last_generation
View(last_generation)
View(last_generation)
last_generation[[1]]@father
View(breed1_bottleneck)
breed1_bottleneck[[5]]@father
breed1_bottleneck[[4]]@father
pullSnpGeno(last_generation,simParam=SP)
View(breed1_bottleneck)
breed1_bottleneck[[5]]
# Extracting final generation:
last_generation <- breed1_bottleneck[[n_generations]]
last_generation
pullSnpGeno(last_generation,simParam=SP)
View(last_generation)
View(last_generation)
last_generation@geno[[1]]
getSnPMap(last_generation,simParam=SP)
getSnpMap(last_generation,simParam=SP)
getSnpMap(last_generation,simParam=SP)
getSnpMap(last_generation,simParam=SP)
View(last_generation)
View(last_generation)
View(breed1_bottleneck)
View(founderpop)
View(founderGenomes)
SP$addSnpChip(5)
getSnpMap(snpChip=1,last_generation,simParam=SP)
SP$addSnpChip(5)
getSnpMap(snpChip=1,simParam=SP)
View(breed1_bottleneck)
View(last_generation)
SP$addSnpChip(5)
getSnpMap(snpChip=1,simParam=SP)
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
# # Change working directory
# setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
help(runMacs2)
founderGenomes <- runMacs2(nInd = 100,
nChr = 1,
Ne = 2500,
histNe = NULL,
histGen = NULL)
# Inspecting the founderGenomes object
founderGenomes
help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
SP$setSexes("yes_sys")
SP$setVarE(h2 = 0.2)
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
# # Change working directory
# setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
help(runMacs2)
founderGenomes <- runMacs2(nInd = 100,
nChr = 1,
Ne = 2500,
histNe = NULL,
histGen = NULL)
# Inspecting the founderGenomes object
founderGenomes
help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
SP$setSexes("yes_sys")
SP$addSnpChip(nSnpPerChr = 1000)
SP$setTrackRec(TRUE)
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# Set misc used for setting years of birth for the first individuals
current_generation = 0
founderpop = setMisc(x = founderpop,
node = "generation",
value = current_generation)
head(getMisc(x = founderpop, node = "generation"))
# Split the founder population into two breeding groups
breed1_founders <- founderpop[1:50]
breed1_founders
breed2_founders <- founderpop[51:100]
breed2_founders
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1,
mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating randomm mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
bottleneck_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
return(bottleneck_generations)
}
n_generations <- 5
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, n_generations)
breed2_bottleneck <- random_mating(breed2_founders, SP, n_generations)
# founders
founderpop
breed1_bottleneck
# Extracting final generation:
last_generation <- breed1_bottleneck[[n_generations]]
last_generation
pullSnpGeno(last_generation,simParam=SP)
# SP$addSnpChip(5)
# getSnpMap(snpChip=1,simParam=SP)
getSnpMap(simParam=SP)
writePlink(last_generation,simParam=SP)
writePlink(last_generation,simParam=SP)
writePlink(last_generation,simParam=SP, baseName='writePlink_test',
,
)
writePlink(last_generation,simParam=SP, baseName='writePlink_test',
)
writePlink(last_generation, baseName = 'writePlink_test')
View(last_generation)
last_generation$columns
last_generation@
last_generation@@
last_generation@pheno
last_generation@nLoci
writePlink(last_generation,simParam=SP, baseName='writePlink_test',
traits = 1,
use = "rand"
)
View(last_generation)
last_generation@geno
download_plink(dir = tempdir(), overwrite = FALSE, verbose = TRUE)
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
# # Change working directory
# setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
help(runMacs2)
founderGenomes <- runMacs2(nInd = 100,
nChr = 1,
Ne = 2500,
histNe = NULL,
histGen = NULL)
# Inspecting the founderGenomes object
founderGenomes
help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
SP$setSexes("yes_sys")
SP$addSnpChip(nSnpPerChr = 1000)
SP$setTrackRec(TRUE)
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# Set misc used for setting years of birth for the first individuals
current_generation = 0
founderpop = setMisc(x = founderpop,
node = "generation",
value = current_generation)
head(getMisc(x = founderpop, node = "generation"))
# Split the founder population into two breeding groups
breed1_founders <- founderpop[1:50]
breed1_founders
breed2_founders <- founderpop[51:100]
breed2_founders
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1,
mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating randomm mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
bottleneck_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
return(bottleneck_generations)
}
n_generations <- 5
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, n_generations)
breed2_bottleneck <- random_mating(breed2_founders, SP, n_generations)
# founders
founderpop
breed1_bottleneck
# Extracting final generation:
last_generation <- breed1_bottleneck[[n_generations]]
last_generation
pullSnpGeno(last_generation,simParam=SP)
# SP$addSnpChip(5)
# getSnpMap(snpChip=1,simParam=SP)
getSnpMap(simParam=SP)
knitr::opts_chunk$set(echo = TRUE)
# Defining the relative path in the repository
repository_path <- "/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations"
# Set the path to your GitHub folder
YOUR_GITHUB_ROOT_DIRECTORY <- "C:/Users/jonat/GitHub"
# Set the root directory for notebook chunks
knitr::opts_knit$set(root.dir = file.path(YOUR_GITHUB_ROOT_DIRECTORY, repository_path))
# # Verify the current working directory
# getwd()
library(ggplot2) # If not already loaded
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Fit a normal distribution to the data
fit <- fitdistr(values, "normal")
# Load the MASS package for fitdistr function
library(MASS)
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Fit a normal distribution to the data
fit <- fitdistr(values, "normal")
# Extract mean and standard deviation from the fitted distribution
mean_val <- fit$estimate["mean"]
sd_val <- fit$estimate["sd"]
# Compute the threshold for the 30% most extreme values
threshold <- qnorm(0.3, mean = mean_val, sd = sd_val)
# Identify extreme values
extreme_values <- values[values > threshold]
# Print the extreme values
print(extreme_values)
# Load the MASS package for fitdistr function
library(MASS)
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Fit a normal distribution to the data
fit <- fitdistr(values, "normal")
# Extract mean and standard deviation from the fitted distribution
mean_val <- fit$estimate["mean"]
sd_val <- fit$estimate["sd"]
# Compute the threshold for the 30% most extreme values
#threshold <- qnorm(0.3, mean = mean_val, sd = sd_val)
threshold <- qnorm(0.05, mean = mean_val, sd = sd_val)
# Identify extreme values
extreme_values <- values[values > threshold]
# Print the extreme values
print(extreme_values)
# Load the MASS package for fitdistr function
library(MASS)
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Fit a normal distribution to the data
fit <- fitdistr(values, "normal")
# Extract mean and standard deviation from the fitted distribution
mean_val <- fit$estimate["mean"]
sd_val <- fit$estimate["sd"]
# Compute the threshold for the 30% most extreme values
#threshold <- qnorm(0.3, mean = mean_val, sd = sd_val)
threshold <- qnorm(0.05, mean = mean_val, sd = sd_val)
# Identify extreme values
extreme_values <- values[values > threshold]
# Print the extreme values
print(extreme_values)
# Load the MASS package for fitdistr function
library(MASS)
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Fit a normal distribution to the data
fit <- fitdistr(values, "normal")
# Extract mean and standard deviation from the fitted distribution
mean_val <- fit$estimate["mean"]
sd_val <- fit$estimate["sd"]
# Compute the threshold for the 30% most extreme values
#threshold <- qnorm(0.3, mean = mean_val, sd = sd_val)
# threshold <- qnorm(0.05, mean = mean_val, sd = sd_val)
threshold <- qnorm(0.001, mean = mean_val, sd = sd_val)
# Identify extreme values
extreme_values <- values[values > threshold]
# Print the extreme values
print(extreme_values)
# Load the MASS package for fitdistr function
library(MASS)
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Fit a normal distribution to the data
fit <- fitdistr(values, "normal")
# Extract mean and standard deviation from the fitted distribution
mean_val <- fit$estimate["mean"]
sd_val <- fit$estimate["sd"]
# Compute the threshold for the 30% most extreme values
#threshold <- qnorm(0.3, mean = mean_val, sd = sd_val)
# threshold <- qnorm(0.05, mean = mean_val, sd = sd_val)
threshold <- qnorm(0.0001, mean = mean_val, sd = sd_val)
# Identify extreme values
extreme_values <- values[values > threshold]
# Print the extreme values
print(extreme_values)
# Load the MASS package for fitdistr function
library(MASS)
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Sort the values in descending order to find the top 1%
sorted_values <- sort(values, decreasing = TRUE)
# Calculate the threshold for the top 1%
threshold_index <- ceiling(0.01 * length(sorted_values))
threshold <- sorted_values[threshold_index]
# Identify genomic windows with ROH frequency above the threshold
top_1_percent_ROH <- data[data$V4 > threshold, ]
# Print the top 1% of ROH regions
print(top_1_percent_ROH)
knitr::opts_chunk$set(echo = TRUE)
# Defining the relative path in the repository
repository_path <- "/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations"
# Set the path to your GitHub folder
YOUR_GITHUB_ROOT_DIRECTORY <- "C:/Users/jonat/GitHub"
# Set the root directory for notebook chunks
knitr::opts_knit$set(root.dir = file.path(YOUR_GITHUB_ROOT_DIRECTORY, repository_path))
# # Verify the current working directory
# getwd()
# Load the MASS package for fitdistr function
library(MASS)
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Sort the values in descending order to find the top 1%
sorted_values <- sort(values, decreasing = TRUE)
# Calculate the threshold for the top 1%
threshold_index <- ceiling(0.01 * length(sorted_values))
threshold <- sorted_values[threshold_index]
# Identify genomic windows with ROH frequency above the threshold
top_1_percent_ROH <- data[data$V4 > threshold, ]
# Print the top 1% of ROH regions
print(top_1_percent_ROH)
View(top_1_percent_ROH)
# Load the MASS package for fitdistr function
library(MASS)
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Sort the values in descending order to find the top 1%
sorted_values <- sort(values, decreasing = TRUE)
# Calculate the threshold for the top 1%
threshold_index <- ceiling(0.05 * length(sorted_values))
threshold <- sorted_values[threshold_index]
# Identify genomic windows with ROH frequency above the threshold
top_1_percent_ROH <- data[data$V4 > threshold, ]
# Print the top 1% of ROH regions
print(top_1_percent_ROH)
# Load the MASS package for fitdistr function
library(MASS)
# Read the data
data <- read.table("sorted_population_coverage.bed", header = FALSE)
# Assuming your data is in the fourth column
values <- data$V4
# Sort the values in descending order to find the top 1%
sorted_values <- sort(values, decreasing = TRUE)
# Calculate the threshold for the top 1%
threshold_index <- ceiling(0.05 * length(sorted_values))
threshold <- sorted_values[threshold_index]
# Identify genomic windows with ROH frequency above the threshold
top_5_percent_ROH <- data[data$V4 > threshold, ]
# Print the top 1% of ROH regions
print(top_5_percent_ROH)
