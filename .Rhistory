return(generations[-1])
}
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd
generations <- vector(length = n_gen + 1, mode = "list")
generations[[1]] <- pop
for (gen_ix in 2:(n_gen + 1)) {
# Generate progeny using randCross
progeny <- randCross(pop = generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1, simParam = SP)
# Check if progeny contains individuals before recording data
if (length(progeny@id) > 0) {
print(paste("Generation:", gen_ix, "Number of progeny:", length(progeny@id)))
print(paste("Before recordData for generation", gen_ix - 1, ":", nrow(progeny)))
# Extract relevant information from progeny
progeny_data <- data.frame(
id = progeny@id,
father = progeny@father,
mother = progeny@mother,
sex = progeny@sex,
generation = unlist(getMisc(x = progeny, node = "generation")),
generation_progeny = gen_ix - 1
)
# Record data for the current generation
generations[[gen_ix]] <- recordData(data = generations[[gen_ix]], pop = progeny_data, generationOfUse = gen_ix - 1)
print(paste("After recordData for generation", gen_ix - 1, ":", nrow(generations[[gen_ix]])))
} else {
print(paste("Generation:", gen_ix, "No progeny generated. Skipping recordData."))
}
}
return(generations[-1])
}
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd
generations <- vector(length = n_gen + 1, mode = "list")
generations[[1]] <- pop
for (gen_ix in 2:(n_gen + 1)) {
# Generate progeny using randCross
progeny <- randCross(pop = generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1, simParam = SP)
# Check if progeny contains individuals before recording data
if (length(progeny@id) > 0) {
print(paste("Generation:", gen_ix, "Number of progeny:", length(progeny@id)))
print(paste("Before recordData for generation", gen_ix - 1, ":", nrow(progeny)))
# Directly append progeny information to the data frame
generations[[gen_ix]] <- recordData(data = generations[[gen_ix]], pop = progeny, generationOfUse = gen_ix - 1)
print(paste("After recordData for generation", gen_ix - 1, ":", nrow(generations[[gen_ix]])))
} else {
print(paste("Generation:", gen_ix, "No progeny generated. Skipping recordData."))
}
}
return(generations[-1])
}
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd
last_generation <- NULL
for (gen_ix in 2:(n_gen + 1)) {
# Generate progeny using randCross
progeny <- randCross(pop = pop, nCrosses = n_ind, nProgeny = 1, simParam = SP)
# Check if progeny contains individuals before processing
if (length(progeny@id) > 0) {
print(paste("Generation:", gen_ix, "Number of progeny:", length(progeny@id)))
# Record data for the current generation
progeny_data <- data.frame(
id = progeny@id,
father = progeny@father,
mother = progeny@mother,
sex = progeny@sex,
generation = unlist(getMisc(x = progeny, node = "generation")),
generation_progeny = gen_ix - 1
)
# Store data for the last generation
last_generation <- progeny_data
} else {
print(paste("Generation:", gen_ix, "No progeny generated."))
}
}
return(last_generation)
}
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd
last_generation <- NULL
for (gen_ix in 2:(n_gen + 1)) {
# Generate progeny using randCross
progeny <- randCross(pop = pop, nCrosses = n_ind, nProgeny = 1, simParam = SP)
# Check if progeny contains individuals before processing
if (length(progeny@id) > 0) {
print(paste("Generation:", gen_ix, "Number of progeny:", length(progeny@id)))
# Record data for the current generation
progeny_data <- data.frame(
id = progeny@id,
father = progeny@father,
mother = progeny@mother,
sex = progeny@sex,
generation = unlist(getMisc(x = progeny, node = "generation")),
generation_progeny = gen_ix - 1
)
# Append data for the current generation to the last generation
if (is.null(last_generation)) {
last_generation <- progeny_data
} else {
last_generation <- rbind(last_generation, progeny_data)
}
} else {
print(paste("Generation:", gen_ix, "No progeny generated."))
}
}
return(last_generation)
}
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1, mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating random mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
last_generation <- as.data.frame(generations[[n_gen + 1]])  # Convert the last generation to a data frame
return(last_generation)
}
# Example usage
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1, mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating random mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop = generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
last_generation <- data.frame(
id = generations[[n_gen + 1]]@id,
father = generations[[n_gen + 1]]@father,
mother = generations[[n_gen + 1]]@mother,
sex = generations[[n_gen + 1]]@sex,
generation = unlist(getMisc(x = generations[[n_gen + 1]], node = "generation")),
generation_progeny = n_gen
)
return(last_generation)
}
# Example usage
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1, mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating random mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop = generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
last_generation <- NULL
if (length(generations[[n_gen + 1]]@id) > 0) {
last_generation <- data.frame(
id = generations[[n_gen + 1]]@id,
father = generations[[n_gen + 1]]@father,
mother = generations[[n_gen + 1]]@mother,
sex = generations[[n_gen + 1]]@sex,
generation = unlist(getMisc(x = generations[[n_gen + 1]], node = "generation")),
generation_progeny = n_gen
)
} else {
warning("No individuals in the last generation.")
}
return(last_generation)
}
# Example usage
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1, mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating random mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop = generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
last_generation <- generations[[n_gen + 1]]
if (length(last_generation@id) > 0) {
last_generation <- data.frame(
id = last_generation@id,
father = last_generation@father,
mother = last_generation@mother,
sex = last_generation@sex,
generation = unlist(getMisc(x = last_generation, node = "generation")),
generation_progeny = n_gen
)
} else {
warning("No individuals in the last generation.")
last_generation <- NULL  # or data.frame() if you prefer an empty data frame
}
return(last_generation)
}
# Example usage
breed1_bottleneck <- random_mating(breed1_founders, SP, 5)
# Clean the working environment
rm(list = ls())
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
setwd()
setwd(C:\Users\jonat\GitHub\Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations)
setwd(C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations)
setwd(/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations)
setwd(GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations)
setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
# # Change working directory
# setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
help(runMacs2)
founderGenomes <- runMacs2(nInd = 100,
nChr = 1,
Ne = 2500,
histNe = NULL,
histGen = NULL)
# Inspecting the founderGenomes object
founderGenomes
help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
SP$addTraitA(nQtlPerChr = 10) # Trait 1 is affected by 10 QTL/chromosme
# Inspecting the traits element of the SB object
SP$traits
SP$setSexes("yes_sys")
SP$setVarE(h2 = 0.2)
SP$addSnpChip(nSnpPerChr = 1000)
SP$setTrackRec(TRUE)
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# Set misc used for setting years of birth for the first individuals
current_generation = 0
founderpop = setMisc(x = founderpop,
node = "generation",
value = current_generation)
head(getMisc(x = founderpop, node = "generation"))
# Split the founder population into two breeding groups
breed1_founders <- founderpop[1:50]
breed1_founders
breed2_founders <- founderpop[51:100]
breed2_founders
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1,
mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating randomm mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
bottleneck_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
return(bottleneck_generations)
}
n_generations <- 5
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, n_generations)
breed2_bottleneck <- random_mating(breed2_founders, SP, n_generations)
# founders
founderpop
breed1_bottleneck
# founders
founderpop
breed1_bottleneck
# Extracting final generation:
last_generation <- breed1_bottleneck [[n_generations + 1]]
# Extracting final generation:
last_generation <- breed1_bottleneck[n_generations + 1]
last_generation
# founders
founderpop
breed1_bottleneck
# Extracting final generation:
last_generation <- breed1_bottleneck[n_generations]
last_generation
View(last_generation)
View(last_generation)
last_generation[[1]]@father
View(breed1_bottleneck)
breed1_bottleneck[[5]]@father
breed1_bottleneck[[4]]@father
pullSnpGeno(last_generation,simParam=SP)
View(breed1_bottleneck)
breed1_bottleneck[[5]]
# Extracting final generation:
last_generation <- breed1_bottleneck[[n_generations]]
last_generation
pullSnpGeno(last_generation,simParam=SP)
View(last_generation)
View(last_generation)
last_generation@geno[[1]]
getSnPMap(last_generation,simParam=SP)
getSnpMap(last_generation,simParam=SP)
getSnpMap(last_generation,simParam=SP)
getSnpMap(last_generation,simParam=SP)
View(last_generation)
View(last_generation)
View(breed1_bottleneck)
View(founderpop)
View(founderGenomes)
SP$addSnpChip(5)
getSnpMap(snpChip=1,last_generation,simParam=SP)
SP$addSnpChip(5)
getSnpMap(snpChip=1,simParam=SP)
View(breed1_bottleneck)
View(last_generation)
SP$addSnpChip(5)
getSnpMap(snpChip=1,simParam=SP)
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
# # Change working directory
# setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
help(runMacs2)
founderGenomes <- runMacs2(nInd = 100,
nChr = 1,
Ne = 2500,
histNe = NULL,
histGen = NULL)
# Inspecting the founderGenomes object
founderGenomes
help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
SP$setSexes("yes_sys")
SP$setVarE(h2 = 0.2)
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
# # Change working directory
# setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
help(runMacs2)
founderGenomes <- runMacs2(nInd = 100,
nChr = 1,
Ne = 2500,
histNe = NULL,
histGen = NULL)
# Inspecting the founderGenomes object
founderGenomes
help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
SP$setSexes("yes_sys")
SP$addSnpChip(nSnpPerChr = 1000)
SP$setTrackRec(TRUE)
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# Set misc used for setting years of birth for the first individuals
current_generation = 0
founderpop = setMisc(x = founderpop,
node = "generation",
value = current_generation)
head(getMisc(x = founderpop, node = "generation"))
# Split the founder population into two breeding groups
breed1_founders <- founderpop[1:50]
breed1_founders
breed2_founders <- founderpop[51:100]
breed2_founders
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1,
mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating randomm mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
bottleneck_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
return(bottleneck_generations)
}
n_generations <- 5
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, n_generations)
breed2_bottleneck <- random_mating(breed2_founders, SP, n_generations)
# founders
founderpop
breed1_bottleneck
# Extracting final generation:
last_generation <- breed1_bottleneck[[n_generations]]
last_generation
pullSnpGeno(last_generation,simParam=SP)
# SP$addSnpChip(5)
# getSnpMap(snpChip=1,simParam=SP)
getSnpMap(simParam=SP)
writePlink(last_generation,simParam=SP)
writePlink(last_generation,simParam=SP)
writePlink(last_generation,simParam=SP, baseName='writePlink_test',
,
)
writePlink(last_generation,simParam=SP, baseName='writePlink_test',
)
writePlink(last_generation, baseName = 'writePlink_test')
View(last_generation)
last_generation$columns
last_generation@
last_generation@@
last_generation@pheno
last_generation@nLoci
writePlink(last_generation,simParam=SP, baseName='writePlink_test',
traits = 1,
use = "rand"
)
View(last_generation)
last_generation@geno
download_plink(dir = tempdir(), overwrite = FALSE, verbose = TRUE)
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)
# Clean the working environment
rm(list = ls())
# # Change working directory
# setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")
help(runMacs2)
founderGenomes <- runMacs2(nInd = 100,
nChr = 1,
Ne = 2500,
histNe = NULL,
histGen = NULL)
# Inspecting the founderGenomes object
founderGenomes
help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
SP$setSexes("yes_sys")
SP$addSnpChip(nSnpPerChr = 1000)
SP$setTrackRec(TRUE)
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# Set misc used for setting years of birth for the first individuals
current_generation = 0
founderpop = setMisc(x = founderpop,
node = "generation",
value = current_generation)
head(getMisc(x = founderpop, node = "generation"))
# Split the founder population into two breeding groups
breed1_founders <- founderpop[1:50]
breed1_founders
breed2_founders <- founderpop[51:100]
breed2_founders
random_mating <- function(pop, SP, n_gen) {
n_ind <- pop@nInd # Extracting number of individuals in the current population
generations <- vector(length = n_gen + 1,
mode = "list")
generations[[1]] <- pop # The initial breeding group population gets stored as the first element
# Simulating randomm mating to perform simulation of the 2nd until the n+1:th generation
# Each mating Progenys are generated using randcross
for (gen_ix in 2:(n_gen + 1)) {
generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
simParam = SP)
}
bottleneck_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
return(bottleneck_generations)
}
n_generations <- 5
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, n_generations)
breed2_bottleneck <- random_mating(breed2_founders, SP, n_generations)
# founders
founderpop
breed1_bottleneck
# Extracting final generation:
last_generation <- breed1_bottleneck[[n_generations]]
last_generation
pullSnpGeno(last_generation,simParam=SP)
# SP$addSnpChip(5)
# getSnpMap(snpChip=1,simParam=SP)
getSnpMap(simParam=SP)
