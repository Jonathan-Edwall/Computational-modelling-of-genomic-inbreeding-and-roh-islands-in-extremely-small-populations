---
title: "Simulating DNA - Exercise"
author: "Jana Obšteter, Alireza Ehsani, and Gregor Gorjanc"
date: "2022-06-22"
---

# Introduction

In this exercise, you will simulate a population and analyse its genetic variation in three steps and one extra step:

-   Simulate founding genomes,
-   Create a population,
-   Access genomic data, and
-   EXTRA: Calculate genome statistics and summarise them.

For each step, we have given you instructions with an `AlphaSimR` template code to complete (replace ??? with an appropriate code).

This exercise deliberately goes beyond the material we have covered up to now. To help you on this pathway, we indicate which functions should be used and we point to their documentation. Embracing this growth mindset is important for mastering AlphaSimR and combining it with other R functionality.

# Simulate founding genomes

## Use the following parameters:

-   **20 individuals**

-   **3 chromosomes**

-   **100 segregating loci (sites) per chromosome**

-   **MAIZE species**

Note that maize has 10 chromosome pairs, **but to speed up this session we will only simulate 3 chromosome pairs.**

If you get errors or get lost, remember to use help(runMacs)

```{r}
library(AlphaSimR)
help(quickHaplo)
help(runMacs)
```

```{r}
# Clean the working environment
rm(list = ls())

# Set the default plot layout
par(mfrow = c(1, 1))





founderGenomes = runMacs(nInd = 5,
                         nChr = 2,
                         segSites = 4,
                         species = "CATTLE")
```

## Inspecting the founderGenomes object

-   Notice 8 loci, 4 for each chromosome

```{r}
founderGenomes
```

# Global Simulation Parameters

After creating the founding genomes, we must use the `SimParam()` function to create an object that contains global simulation parameters. These simulation parameters will be common to all downstream AlphaSimR work. You can read more about the `SimParam() function` and its many methods in the help apge provided with `Help(SimParam)`

**Simparam == Simulation parameters**

\*\* Container for global simulation parameters. Saving this object as SP will allow it to be accessed by function defaults.

### Important note about SimParam objects!!!

When the SimParam object gets named **SP**, then AlphaSimR functions recognise it and use it automatically **without you having to pass it as an argument to each function**.

**If you will have named this object as say, SP2, then you would have to pass the SP2 object to every AlphaSimR function, which gets annoying**

===\> Therefore its recommended to save the SimParam object as an object named **SP**.

```{r}
help(SimParam)
```

```{r}
# Create an object holding the global simulation parameter object (SP) from the founder genomes
SP = SimParam$new(founderGenomes)
```

### Set Sex

If you wish to assign sex, you can use the `SimParam\$setSexes()`.

We're simulating cattle here. And as we know, cattle have male and female individuals. But AlphaSimR does not simulate sex by default because it handles both animals and plants. And in plants we know that sometimes we don't have sex. So to actually get sex, we will request this through the `setSexes()` method of the SimParam. But since the simulation parameter has been actually stored in the SP object, we need to now call `SP$setSexes()`.

We're going to setSexes systematically, so we're going to use the option **yes_sys,which will systematically create a male and a female in a sequence** You can read more about the other sex option, sex options with the help SimParam.

```{r}
# yes_sys will systematically create a Male and female in a sequence 


SP$setSexes("yes_sys")

# Skip sex allocation in this example because maize individuals have "male" and
#   "female" reproductive organs).


```

# Create a base population of individuals - newPop()

Now let's create an actual population of individuals. To do that, we're going to use the `newPop()` function and that newPop function is going to create a new population. A population is just a group of individuals. Genomes of these individuals will be created from the founding genomes and their sex will be allocated according to the 'SP\$setSexes' specification. If we want to know more about the new population, just run 'help(newPop)' and you're gonna get information about how to create a new population. We're going to name this population simply as a base population. And we're going to, in R, we're going to name this object basePop.

```{r}
help(newPop)
# Now create a population of individuals from founding genomes
basePop = newPop(founderGenomes)
```

### Inspect the basePop object: (maize population)¨

-   5 Diploid individuals based on the founding genomes, with 8 Loci

At the moment **we don't have any traits. We're going to deal with the traits later on** So this AlphaSimR populations contain lots of information about the individuals. For example, **you will see information about the individual identification that is:**

-   The name of these individuals.

-   Information about the mother, the father,

-   The sex - Information about traits,

-   Any miscellaneous information.

-   You will see the number of individuals

-   Some genome information

-   And finally, the genomes of these individuals.

```{r}
basePop
```

We usually don't recommend **looking too much into the structure of the objects. But if you want to do that, you can use the R function `str()`,** and that's what I'm gonna run now on the basePop. You will see quite a lot of verbose output here. The details don't really matter, but you can see here information about: - The individual

-   mother

-   father

-   sex.

There's gonna be a big block about the traits that we haven't yet defined.

-   There can be some miscellaneous list for every single individual,

-   There is some information about the numbers.

-   Finally the genome of the individual.

So we have simulated, as we know, we have five individuals here. And you might look at these entries here and you might not recognise that this would be DNA, \*\* but I'm going to show you actually how to look into these values just now\*\*

```{r}
str(basePop)

```

# Access genomic data

In most cases in R you have S3 style for accessing object (Where elements of an object or accessed by using saying:**object_name\$element_name**.

AlphaSimR uses the S4 style for population objects, meaning: you access elements by writing: **object_name \@ element_name**

### Inspect the number of individuals in the population

```{r}
basePop@nInd
```

### Inspect the individuals identifications (their "name")

```{r}
basePop@id
```

### Inspect the sex of the individuals

```{r}
basePop@sex
```

### Inspect the nr of chromosomes simulated

```{r}
basePop@nChr
```

### Inspect the nr of loci per chromosome

**Notice that we get "4 4" since we have:**

-   4 loci on the 1st chromosome

-   4 loci on the 2nd chromosome

```{r}
basePop@nLoci
```

## Looking at Genomes of population Individuals

Now we're going to look at the function called `pullSegSiteHaplo()`

This function will get haplotypes and it's going to get haplotypes across all segregating sites. You can see more about this function by looking at its Help page. I'm now going to do that for our base population.

### The output will be a matrix of haplotypes

#### Rows == Haplotypes :

-   **1 haplotype per row**

In this case we simulated a diploid species

**===\> we get two haplotypes (rows) per individual.**

**11_1** and **11_2** are the **two haplotypes for individual 11** as an example

#### Columns == Locus alleles:

All these columns span across all of the chromosomes

-   **1 locus allele per column**

**The locis are named as: chromosome_locus.**

-   **1_2** therefore refers to: **chromsome 1**, **locus 2**

The combination of haplotypes of an individual form the genotype of that individual. When we present the genotype as a allele dosage, that is, the number of mutations that an individual carries at each locus. We can obtain individual's genotype by simply adding up it's haplotypes.

We're going to show here how to do this by combining the AlphaSimR and other R functionality, **to obtain the genotype of an individual.**

**#1: So what I'm going to first do is I'm going to extract the haplotypes from the base population.** - I'm saving the haplotypes in the hap object, you can see the printout as before, but now these values are actually stored in the hap object.

```{r}
# Access haplotypes of the individuals in our base population
hap = pullSegSiteHaplo(basePop)
hap
# # Access haplotypes of maize plants in the maizePop object
# maizeHaplo = pullSegSiteHaplo(???)
# 
# # Check the first 10 haplotypes at the first 10 loci
# maizeHaplo[1:10, 1:10]
# 
# # Check the first 5 genotypes at the first 10 loci
# maizeGeno = pullSegSiteGeno(???)
# maizeGeno[???, 1:10]
```

## Extract the haplotypes for the first individual

**Now I'm going to try to extract haplotype for the first individua**

I'm going to write the hap object & and I'm going to use the square brackets to go inside the matrix. And I'm only going to say I need:

-   the first row

-   and I want all the columns, so I'm just going to leave the one for the column empty.

```{r}
hap[1:2,]
```

## Genotype: Extracting the genotype for the first individual from hap-object

```{r}
hap[1,] + hap[2,]
```

## Genotype: Extracting the genotype of ALL individuals using pullSegSiteGeno()

Because accessing the genotype of individual is a really common operation. We also have the `pullSegSiteGeno()` function. This function returns one row per individual, which is the sum of haplotype rows as shown above. And let's run this.

**5 rows here, for all the 5 individuals** - Here we have the allele dosages for each individual, at each position

```{r}
pullSegSiteGeno(basePop)
```

There are also other functions to access genomic information from AlphaSimR population. And you can read them about these functions from `help(package="AlphaSimR")` where they list all of the functions provided by the package.

You get this overview of the AlphaSimR packages and other recommendations for this package. And if I scroll down, you'll see quite a long list of functions. And if I focus on P for Pull functions, you're going to see there's quite a number of functions that enable us to extract the IBD information, specific marker, genotype or haplotype, QTLs, all segregating sites or a specific set of so-called snip markers.

# EXTRA: Calculate genome statistics and summarise them

To demonstrate the joint use of AlphaSimR and base R functionality, we will now analyse the simulated genomes by calculating two common statistics: allele frequency and correlation between allele dosages at different loci. We have not covered these topics previously, so, this is a guided exercise;

Allele frequency describes the proportion of mutations at a locus.

```{r}
# Calculate frequency of mutant alleles in the haplotypes at each locus using the
# colMeans() function
alleleFreq = colMeans(hap)

# Summarise allele frequencies
print(alleleFreq)
hist(alleleFreq)
# We usually see more loci with lower allele frequencies indicating younger
# mutations or mutations that were selected against.
```

Correlation between allele dosages at different loci describes the extent of linkage between the loci. We expect higher absolute correlation (away from 0) between nearby loci because they are physically linked and there is a small probability of recombination between nearby loci. As the physical distance between loci increases, probability of recombination increases, which in turn reduces the correlations between allele dosages at distant loci (more on recombination in other sessions).

```{r}
# Calculate correlations between allele dosages at the haplotype loci
lociCor = cor(???)

# Inspect some correlations
str(lociCor) # lociCor is a matrix of correlations
lociCor[1:5, 1:5]

# Summarise the correlations
hist(lociCor)
# Correlations are distributed around zero because most pairs of loci are far
# apart, but there are some pairs of loci with larger correlations
```

```{r}
# Plot correlations between the first 100 loci (these span chromosome 1)
lociCorChr1 = lociCor[1:100, 1:100]
image(lociCorChr1,
      xlab = "Relative locus position", ylab = "Relative locus position")
# Focusing on just one chromosome we can see elevated correlations (darker colour)
# around the diagonal of the matrix - this is correlation between nearby loci
```

```{r}
# EXTRA: Plot the correlations between loci as a function of genetic distance
# between the loci (no need to change any of the code below - just run it!).
lociCorChr1Val = c(lociCorChr1[lower.tri(lociCorChr1)])
lociCorChr1Dis = outer(SP$genMap[[1]], SP$genMap[[1]], FUN = "-")
lociCorChr1Dis = lociCorChr1Dis[lower.tri(lociCorChr1Dis)]
plot(x = lociCorChr1Dis, y = abs(lociCorChr1Val),
     xlab = "Distance between loci", ylab = "Correlation")
lines(lowess(x = lociCorChr1Dis, y = abs(lociCorChr1Val)), col = "red")
# We plot absolute value of correlations to focus only on the magnitude of values.
# Black points show correlations between loci, while the red line shows smoothed
# average correlation. There are too many black points though, so we can't see
# the data clearly.
```

#heeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeej

```{r}
# EXTRA: A clearer way to present such data is to use `smoothScatter()`
smoothScatter(x = lociCorChr1Dis, y = abs(lociCorChr1Val),
              xlab = "Distance between loci", ylab = "Correlation")
lines(lowess(x = lociCorChr1Dis, y = abs(lociCorChr1Val)), col = "red")
# Blue colour represents smoothed density of our data points - the darker the
# colour the more data points there are in one area. We use this plotting method
# when we have many data points that overlay each other. See help(smoothScatter)
# for more details.
# 
# Have you expected higher correlation between nearby loci?
# You can repeat the simulation with a larger number of segregating loci, say
# at least 1000 per chromosome, to capture more nearby loci. Also, you should
# revisit this analysis with a population under selection.
```
