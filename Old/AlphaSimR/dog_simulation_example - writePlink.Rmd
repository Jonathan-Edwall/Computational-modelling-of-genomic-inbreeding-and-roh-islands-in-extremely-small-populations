---
title: "dog_simulation_example.R"
output: html_document
date: "2024-01-31"
---

# Loading libraries

```{r library()}
library(AlphaSimR)
library(dplyr)
library(ggplot2)
library(patchwork)
library(purrr)
library(tibble)

# Clean the working environment
rm(list = ls())

# # Change working directory
# setwd("C:/Users/jonat/GitHub/Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations")


```

# Generating founder population - runMacs2()

`runMacs2` Parameters:

-   nInd = 100: 100 individuals in the founder population

-   nChr = 1: Haplotypes are created for 1 chromosome per individual

-   Ne = 2500: Effective population size: 2500 (Ne)

-   HistNe = NULL: No effective population size defined from previous generations (histNe = NULL)

-   histGen = NULL: If HistNe was defined, this parameter would define the number of generations ago we had the Ne defined in HistNe

```{r runMacs2()}
help(runMacs2)

founderGenomes <- runMacs2(nInd = 100,
                     nChr = 1,
                     Ne = 2500,
                     histNe = NULL,
                     histGen = NULL)

# Inspecting the founderGenomes object
founderGenomes

```

# Setting Global Simulation Parameters - SimParam()

```{r SimParam()}

help(SimParam)

# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes) 
# SP

```


## Assigning Sexes to the population - SimParam\$setSexes()

`SP$SetSexes()` assignes sexes.

**yes_sys**-argument ensures that sexes will be systematically assigned in a sequence like:

-   First male

-   Then female

-   Then male

etc".

```{r SimParam$setSexes()}
SP$setSexes("yes_sys")

```

## Randomly assigns eligible SNPs to a SNP chip - SimParam\$addSnpChip()

`SP$addSnpChip()`Randomly assigns eligible SNPs to a SNP chip.

**nSnpPerChr**-argument that assigns for each individuals n SNPs for each chromsome, where n is the user-specified number.

```{r SimParam$addSnpChip()}
SP$addSnpChip(nSnpPerChr = 1000)
```

## Setting on recombination tracking for the simulation - SimParam\$setTrackRec()

Sets recombination tracking for the simulation. By default recombination tracking is turned off. **When turned on recombination tracking will also turn on pedigree tracking.**

**Recombination tracking keeps records of all individuals created,** except those created by hybridCross, because their pedigree is not tracked.

```{r SimParam$setTrackRec()}
SP$setTrackRec(TRUE)
```


## Creating two separate populations for bottleneck event - newPop()

```{r newPop()}
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# Set misc used for setting years of birth for the first individuals
current_generation = 0
founderpop = setMisc(x = founderpop,
                   node = "generation",
                   value = current_generation)
head(getMisc(x = founderpop, node = "generation"))


# Split the founder population into two breeding groups
breed1_founders <- founderpop[1:50]
breed1_founders

breed2_founders <- founderpop[51:100]
breed2_founders

```

# Simulation

## Bottleneck Simulation for 10 Generations - randCross()

`randCross()` simulates random mating.

-   **nCrosses**-argument specifies how many times an individual in the population can be a parent. In this case, an individual can only be a parent once (random mating)

-   **nProgeny**-argument specifies how many progeny's each mating pair can have. In this case, this parameter is set at 1 progeny per mating pair.

-   **simParam**-argument specifies the global simulation parameters



## original random_mating funktion:

```{r}
random_mating <- function(pop, SP, n_gen) {
    n_ind <- pop@nInd # Extracting number of individuals in the current population
    generations <- vector(length = n_gen + 1,
                          mode = "list") 
    generations[[1]] <- pop # The initial breeding group population gets stored as the first element
    
    # Simulating randomm mating to perform simulation of the 2nd until the n+1:th generation
    # Each mating Progenys are generated using randcross
    for (gen_ix in 2:(n_gen + 1)) {
        generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
                                           simParam = SP)
    }
     bottleneck_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
    
    return(bottleneck_generations)
}

n_generations <- 5
# Simulating random mating within each breeding group for 5 generations
breed1_bottleneck <- random_mating(breed1_founders, SP, n_generations)
breed2_bottleneck <- random_mating(breed2_founders, SP, n_generations)
```





### Viewing the output from the bottleneck simulation

```{r}

# founders
founderpop
breed1_bottleneck
```

### Extracting the last generation
```{r}
# Extracting final generation:
last_generation <- breed1_bottleneck[[n_generations]]
last_generation
    

```

# Extracting data to PLINK

## pullSnpGeno

Function that retrieves SNP genotype data & returns a matrix of SNP genotypes 
```{r pullSnpGeno()}
pullSnpGeno(last_generation,simParam=SP)
```


## Get SNP genetic map - getSnPMap()



Function that retrieves the genetic map for a given SNP chip & returns a data.frame with:

-   **id:** Unique identifier for the SNP

-   **chr:** Chromosome containing the SNP

-   **site:** Segregating site on the chromosome

-   **pos:** Genetic map position

```{r getSnPMap()}
# SP$addSnpChip(5)
# getSnpMap(snpChip=1,simParam=SP)
getSnpMap(simParam=SP)

```

## writePlink()

**Description**
Functionen that inputs a Pop-class & exports it to PLINK PED and MAP files. 

The arguments for this function were chosen for consistency with RRBLUP2. 
**The base pair coordinate will the locus position as stored in AlphaSimR** & not an actual base pair position, because AlphaSimR doesn’t track base pair positions, **only relative positions for the loci used in the simulation**.


** Usage **
writePlink(
pop,
baseName,
traits = 1,
use = "pheno",
snpChip = 1,
useQtl = FALSE,
simParam = NULL,
...
)

**Arguments: **

-   **pop** an object of Pop-class

-   **baseName** basename for PED and MAP files.

-   **traits** an integer indicating the trait to write, a trait name, or a function of the traits
returning a single value.

-   **use** what to use for PLINK’s phenotype field. Either phenotypes "pheno", genetic
values "gv", estimated breeding values "ebv", breeding values "bv", or random
values "rand".

-   **snpChip** an integer indicating which SNP chip genotype to use
useQtl should QTL genotypes be used instead of a SNP chip. 

           -    If TRUE, snpChip specifies which trait’s QTL to use, and thus these QTL may not match the QTL underlying the phenotype supplied in traits.
           
-   **simParam** an object of SimParam
... additional arguments if using a function for traits

```{r}
writePlink(last_generation,simParam=SP, baseName='writePlink_test',
           
            traits = 1,
           use = "rand"
           
           
           )
```


<!-- ## Performing selection -->

```{r}

# breeding <- function(pop, SP, n_gen, n_sires, size) {
#     generations <- vector(length = n_gen + 1,
#                           mode = "list")
#     generations[[1]] <- pop
#     for (gen_ix in 2:(n_gen + 1)) {
#         n_females <- generations[[gen_ix - 1]]@nInd/2
#         generations[[gen_ix]] <- selectCross(generations[[gen_ix - 1]], 
#                                              nMale = n_sires,
#                                              nFemale = n_females,
#                                              nCrosses = size,
#                                              use = "pheno",
#                                              nProgeny = 1,
#                                              simParam = SP)
#     }
#     generations[-1]
#     
# }
# 
# # Selecting something.. 
```

```{r}
# breed1_selection <- breeding(breed1_bottleneck[[5]],
#                              SP = SP,
#                              n_gen = 20,
#                              n_sires = 20,
#                              size = 200)
# 
# breed2_selection <- breeding(breed2_bottleneck[[5]], 
#                              SP = SP,
#                              n_gen = 20,
#                              n_sires = 20,
#                              size = 200)

```
